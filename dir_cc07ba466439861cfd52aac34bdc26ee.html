<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CORE Game Developers Toolkit: F:/UnityProjects/Unity6/COREGameDevelopersToolkit_BuildIn/Assets/COREToolkit/ThirdParty/UniTask Directory Reference</title>
<link rel="icon" href="CoreLogoSmall.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="CoreLogoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">CORE Game Developers Toolkit<span id="projectnumber">&#160;v1.0.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_cc07ba466439861cfd52aac34bdc26ee.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">UniTask Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_40b28a42b3f779a2394b891de0473eb6.html">Editor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top"><span class="iconfclosed"></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_11e2ca09cc30771d02e4d95d72bfed39.html">Runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a href="https://github.com/Cysharp/UniTask/actions"><img src="https://github.com/Cysharp/UniTask/workflows/Build-Debug/badge.svg" alt="GitHub Actions" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/Cysharp/UniTask/releases"><img src="https://img.shields.io/github/release/Cysharp/UniTask.svg" alt="Releases" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/Cysharp/UniTask/blob/master/README_CN.md"><img src="https://img.shields.io/badge/UniTask-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3-red" alt="Readme_CN" class="inline"/></a></p>
<p>Provides an efficient allocation free async/await integration for Unity.</p>
<ul>
<li>Struct based <code>UniTask&lt;T&gt;</code> and custom AsyncMethodBuilder to achieve zero allocation</li>
<li>Makes all Unity AsyncOperations and Coroutines awaitable</li>
<li>PlayerLoop based task(<code>UniTask.Yield</code>, <code>UniTask.Delay</code>, <code>UniTask.DelayFrame</code>, etc..) that enable replacing all coroutine operations</li>
<li>MonoBehaviour Message Events and uGUI Events as awaitable/async-enumerable</li>
<li>Runs completely on Unity's PlayerLoop so doesn't use threads and runs on WebGL, wasm, etc.</li>
<li>Asynchronous LINQ, with Channel and AsyncReactiveProperty</li>
<li>TaskTracker window to prevent memory leaks</li>
<li>Highly compatible behaviour with Task/ValueTask/IValueTaskSource</li>
</ul>
<p>For technical details, see blog post: <a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQ</a> <br  />
 For advanced tips, see blog post: <a href="https://medium.com/@neuecc/extends-unitywebrequest-via-async-decorator-pattern-advanced-techniques-of-unitask-ceff9c5ee846">Extends UnityWebRequest via async decorator pattern — Advanced Techniques of UniTask</a></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Table of Contents</h1>
<ul>
<li>Getting started</li>
<li>Basics of UniTask and AsyncOperation</li>
<li>Cancellation and Exception handling</li>
<li>Timeout handling</li>
<li>Progress</li>
<li>PlayerLoop</li>
<li>async void vs async UniTaskVoid</li>
<li>UniTaskTracker</li>
<li>External Assets</li>
<li>AsyncEnumerable and Async LINQ</li>
<li>Awaitable Events</li>
<li>Channel</li>
<li>vs Awaitable</li>
<li>For Unit Testing</li>
<li>ThreadPool limitation</li>
<li>IEnumerator.ToUniTask limitation</li>
<li>For UnityEditor</li>
<li>Compare with Standard Task API</li>
<li>Pooling Configuration</li>
<li>Allocation on Profiler</li>
<li>UniTaskSynchronizationContext</li>
<li>API References</li>
<li>UPM Package<ul>
<li>Install via git URL</li>
</ul>
</li>
<li>.NET Core</li>
<li>License</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
Getting started</h1>
<p>Install via UPM package with git reference or asset package(<code>UniTask.*.*.*.unitypackage</code>) available in <a href="https://github.com/Cysharp/UniTask/releases">UniTask/releases</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// extension awaiter/methods can be used by this namespace</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can return type as struct UniTask&lt;T&gt;(or UniTask), it is unity specialized lightweight alternative of Task&lt;T&gt;</span></div>
<div class="line"><span class="comment">// zero allocation and fast excution for zero overhead async/await integrate with Unity</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;string&gt;</a> DemoAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// You can await Unity&#39;s AsyncObject</span></div>
<div class="line">    var asset = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">    var txt = (await UnityWebRequest.Get(<span class="stringliteral">&quot;https://...&quot;</span>).SendWebRequest()).downloadHandler.text;</div>
<div class="line">    await SceneManager.LoadSceneAsync(<span class="stringliteral">&quot;scene2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// .WithCancellation enables Cancel, GetCancellationTokenOnDestroy synchornizes with lifetime of GameObject</span></div>
<div class="line">    <span class="comment">// after Unity 2022.2, you can use `destroyCancellationToken` in MonoBehaviour</span></div>
<div class="line">    var asset2 = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;bar&quot;</span>).WithCancellation(this.GetCancellationTokenOnDestroy());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// .ToUniTask accepts progress callback(and all options), Progress.Create is a lightweight alternative of IProgress&lt;T&gt;</span></div>
<div class="line">    var asset3 = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;baz&quot;</span>).ToUniTask(<a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Progress</a>.Create&lt;<span class="keywordtype">float</span>&gt;(x =&gt; <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x)));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// await frame-based operation like a coroutine</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(100); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// replacement of yield return new WaitForSeconds/WaitForSecondsRealtime</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(10), ignoreTimeScale: <span class="keyword">false</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// yield any playerloop timing(PreUpdate, Update, LateUpdate, etc...)</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(<a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a>.PreLateUpdate);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// replacement of yield return null</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#aaf67b3510a5a7421126aab2c31855408">NextFrame</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// replacement of WaitForEndOfFrame</span></div>
<div class="line"><span class="preprocessor">#if UNITY_2023_1_OR_NEWER</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">WaitForEndOfFrame</a>();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// requires MonoBehaviour(CoroutineRunner))</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">WaitForEndOfFrame</a>(<span class="keyword">this</span>); <span class="comment">// this is MonoBehaviour</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// replacement of yield return new WaitForFixedUpdate(same as UniTask.Yield(PlayerLoopTiming.FixedUpdate))</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a64a8a0cd199604c90d89a8e88160eb80">WaitForFixedUpdate</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// replacement of yield return WaitUntil</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a185785658b777347c3eb9480a9dc8068">WaitUntil</a>(() =&gt; isActive == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// special helper of WaitUntil</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.WaitUntilValueChanged(<span class="keyword">this</span>, x =&gt; x.isActive);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can await IEnumerator coroutines</span></div>
<div class="line">    await FooCoroutineEnumerator();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// You can await a standard task</span></div>
<div class="line">    await Task.Run(() =&gt; 100);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Multithreading, run on ThreadPool under this code</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">SwitchToThreadPool</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* work on ThreadPool */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// return to MainThread(same as `ObserveOnMainThread` in UniRx)</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.SwitchToMainThread();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// get async webrequest</span></div>
<div class="line">    async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;string&gt;</a> GetTextAsync(UnityWebRequest req)</div>
<div class="line">    {</div>
<div class="line">        var op = await req.SendWebRequest();</div>
<div class="line">        <span class="keywordflow">return</span> op.downloadHandler.text;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    var task1 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.com&quot;</span>));</div>
<div class="line">    var task2 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://bing.com&quot;</span>));</div>
<div class="line">    var task3 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://yahoo.com&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// concurrent async-wait and get results easily by tuple syntax</span></div>
<div class="line">    var (google, bing, yahoo) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(task1, task2, task3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// shorthand of WhenAll, tuple can await directly</span></div>
<div class="line">    var (google2, bing2, yahoo2) = await (task1, task2, task3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// return async-value.(or you can use `UniTask`(no result), `UniTaskVoid`(fire and forget)).</span></div>
<div class="line">    <span class="keywordflow">return</span> (asset as TextAsset)?.text ?? <span class="keywordflow">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="stringliteral">&quot;Asset not found&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="a_reflection_baking_build_observer_8cs_html_a0100be52d45f14348918ea69ec09f959"><div class="ttname"><a href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a></div><div class="ttdeci">UnityEngine.Debug Debug</div><div class="ttdef"><b>Definition</b> ReflectionBakingBuildObserver.cs:10</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_progress_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Cysharp.Threading.Tasks.Progress</a></div><div class="ttdoc">Lightweight IProgress[T] factory.</div><div class="ttdef"><b>Definition</b> Progress.cs:11</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">Cysharp.Threading.Tasks.PlayerLoopTiming</a></div><div class="ttdeci">PlayerLoopTiming</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:72</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">Cysharp.Threading.Tasks.UniTask</a></div><div class="ttdoc">Lightweight unity specified task-like object.</div><div class="ttdef"><b>Definition</b> UniTask.Bridge.cs:11</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a1481fa022bf24e63e5668832fdadab80"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">Cysharp.Threading.Tasks.UniTask.SwitchToThreadPool</a></div><div class="ttdeci">static SwitchToThreadPoolAwaitable SwitchToThreadPool()</div><div class="ttdef"><b>Definition</b> UniTask.Threading.cs:57</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a185785658b777347c3eb9480a9dc8068"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a185785658b777347c3eb9480a9dc8068">Cysharp.Threading.Tasks.UniTask.WaitUntil</a></div><div class="ttdeci">static UniTask WaitUntil(Func&lt; bool &gt; predicate, PlayerLoopTiming timing=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.WaitUntil.cs:13</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a49b4d5a8350f7eb8ec7ec47590b81efc"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">Cysharp.Threading.Tasks.UniTask.DelayFrame</a></div><div class="ttdeci">static UniTask DelayFrame(int delayFrameCount, PlayerLoopTiming delayTiming=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:137</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a64a8a0cd199604c90d89a8e88160eb80"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a64a8a0cd199604c90d89a8e88160eb80">Cysharp.Threading.Tasks.UniTask.WaitForFixedUpdate</a></div><div class="ttdeci">static YieldAwaitable WaitForFixedUpdate()</div><div class="ttdoc">Same as UniTask.Yield(PlayerLoopTiming.LastFixedUpdate).</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:112</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a7714cd296ad74e9e0a268573c8e08a53"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">Cysharp.Threading.Tasks.UniTask.WhenAll</a></div><div class="ttdeci">static UniTask WhenAll(params UniTask[] tasks)</div><div class="ttdef"><b>Definition</b> UniTask.WhenAll.cs:31</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a7e9e192d460e9b7c9151cfb0faa93d14"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Cysharp.Threading.Tasks.UniTask.Delay</a></div><div class="ttdeci">static UniTask Delay(int millisecondsDelay, bool ignoreTimeScale=false, PlayerLoopTiming delayTiming=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:147</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a8c208ac2d8c4e186d1c286b6d841b8c1"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">Cysharp.Threading.Tasks.UniTask.WaitForEndOfFrame</a></div><div class="ttdeci">static YieldAwaitable WaitForEndOfFrame()</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:85</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_aaf67b3510a5a7421126aab2c31855408"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#aaf67b3510a5a7421126aab2c31855408">Cysharp.Threading.Tasks.UniTask.NextFrame</a></div><div class="ttdeci">static UniTask NextFrame()</div><div class="ttdoc">Similar as UniTask.Yield but guaranteed run on next frame.</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:49</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_ac44e0c10cd70fc1369711245698795a1"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Cysharp.Threading.Tasks.UniTask.Yield</a></div><div class="ttdeci">static YieldAwaitable Yield()</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:24</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Basics of UniTask and AsyncOperation</h1>
<p>UniTask features rely on C# 7.0(<a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">task-like custom async method builder feature</a>) so the required Unity version is after <code>Unity 2018.3</code>, the official lowest version supported is <code>Unity 2018.4.13f1</code>.</p>
<p>Why is UniTask(custom task-like object) required? Because Task is too heavy and not matched to Unity threading (single-thread). UniTask does not use threads and SynchronizationContext/ExecutionContext because Unity's asynchronous object is automaticaly dispatched by Unity's engine layer. It achieves faster and lower allocation, and is completely integrated with Unity.</p>
<p>You can await <code>AsyncOperation</code>, <code>ResourceRequest</code>, <code>AssetBundleRequest</code>, <code>AssetBundleCreateRequest</code>, <code>UnityWebRequestAsyncOperation</code>, <code>AsyncGPUReadbackRequest</code>, <code>IEnumerator</code> and others when <code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a>;</code>.</p>
<p>UniTask provides three pattern of extension methods.</p>
<div class="fragment"><div class="line">* await asyncOperation;</div>
<div class="line">* .WithCancellation(CancellationToken);</div>
<div class="line">* .ToUniTask(IProgress, <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a>, CancellationToken);</div>
</div><!-- fragment --><p><code>WithCancellation</code> is a simple version of <code>ToUniTask</code>, both return <code>UniTask</code>. For details of cancellation, see: Cancellation and Exception handling section.</p>
<blockquote class="doxtable">
<p>Note: await directly is returned from native timing of PlayerLoop but WithCancellation and ToUniTask are returned from specified PlayerLoopTiming. For details of timing, see: PlayerLoop section. </p>
</blockquote>
<blockquote class="doxtable">
<p>Note: AssetBundleRequest has <code>asset</code> and <code>allAssets</code>, default await returns <code>asset</code>. If you want to get <code>allAssets</code>, you can use <code>AwaitForAllAssets()</code> method. </p>
</blockquote>
<p>The type of <code>UniTask</code> can use utilities like <code>UniTask.WhenAll</code>, <code>UniTask.WhenAny</code>, <code>UniTask.WhenEach</code>. They are like <code>Task.WhenAll</code>/<code>Task.WhenAny</code> but the return type is more useful. They return value tuples so you can deconstruct each result and pass multiple types.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> LoadManyAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// parallel load.</span></div>
<div class="line">    var (a, b, c) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;foo&quot;</span>),</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;bar&quot;</span>),</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;baz&quot;</span>));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;Sprite&gt;</a> LoadAsSprite(<span class="keywordtype">string</span> path)</div>
<div class="line">{</div>
<div class="line">    var resource = await Resources.LoadAsync&lt;Sprite&gt;(path);</div>
<div class="line">    <span class="keywordflow">return</span> (resource as Sprite);</div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void_html"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">Cysharp.Threading.Tasks.UniTaskVoid</a></div><div class="ttdef"><b>Definition</b> UniTaskVoid.cs:13</div></div>
</div><!-- fragment --><p>If you want to convert a callback to UniTask, you can use <code>UniTaskCompletionSource&lt;T&gt;</code> which is a lightweight edition of <code>TaskCompletionSource&lt;T&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> WrapByUniTaskCompletionSource()</div>
<div class="line">{</div>
<div class="line">    var utcs = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source.html">UniTaskCompletionSource&lt;int&gt;</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// when complete, call utcs.TrySetResult();</span></div>
<div class="line">    <span class="comment">// when failed, call utcs.TrySetException();</span></div>
<div class="line">    <span class="comment">// when cancel, call utcs.TrySetCanceled();</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> utcs.Task; <span class="comment">//return UniTask&lt;int&gt;</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source.html">Cysharp.Threading.Tasks.UniTaskCompletionSource</a></div><div class="ttdef"><b>Definition</b> UniTaskCompletionSource.cs:574</div></div>
</div><!-- fragment --><p>You can convert Task -&gt; UniTask: <code>AsUniTask</code>, <code>UniTask</code> -&gt; <code>UniTask&lt;AsyncUnit&gt;</code>: <code>AsAsyncUnitUniTask</code>, <code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>: <code>AsUniTask</code>. <code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>'s conversion cost is free.</p>
<p>If you want to convert async to coroutine, you can use <code>.ToCoroutine()</code>, this is useful if you want to only allow using the coroutine system.</p>
<p>UniTask can not await twice. This is a similar constraint to the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.1">ValueTask/IValueTaskSource</a> introduced in .NET Standard 2.1.</p>
<blockquote class="doxtable">
<p>The following operations should never be performed on a ValueTask&lt;TResult&gt; instance:</p>
<ul>
<li>Awaiting the instance multiple times.</li>
<li>Calling AsTask multiple times.</li>
<li>Using .Result or .GetAwaiter().GetResult() when the operation hasn't yet completed, or using them multiple times.</li>
<li>Using more than one of these techniques to consume the instance.</li>
</ul>
<p>If you do any of the above, the results are undefined. </p>
</blockquote>
<div class="fragment"><div class="line">var task = <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(10);</div>
<div class="line">await task;</div>
<div class="line">await task; <span class="comment">// NG, throws Exception</span></div>
</div><!-- fragment --><p>Store to the class field, you can use <code>UniTask.Lazy</code> that supports calling multiple times. <code>.Preserve()</code> allows for multiple calls (internally cached results). This is useful when there are multiple calls in a function scope.</p>
<p>Also <code>UniTaskCompletionSource</code> can await multiple times and await from many callers.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Cancellation and Exception handling</h1>
<p>Some UniTask factory methods have a <code>CancellationToken cancellationToken = default</code> parameter. Also some async operations for Unity have <code>WithCancellation(CancellationToken)</code> and <code>ToUniTask(..., CancellationToken cancellation = default)</code> extension methods.</p>
<p>You can pass <code>CancellationToken</code> to parameter by standard <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource"><code>CancellationTokenSource</code></a>.</p>
<div class="fragment"><div class="line">var cts = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line"> </div>
<div class="line">cancelButton.onClick.AddListener(() =&gt;</div>
<div class="line">{</div>
<div class="line">    cts.Cancel();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>).SendWebRequest().WithCancellation(cts.Token);</div>
<div class="line"> </div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(1000, cancellationToken: cts.Token);</div>
</div><!-- fragment --><p>CancellationToken can be created by <code>CancellationTokenSource</code> or MonoBehaviour's extension method <code>GetCancellationTokenOnDestroy</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// this CancellationToken lifecycle is same as GameObject.</span></div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(1000, cancellationToken: this.GetCancellationTokenOnDestroy());</div>
</div><!-- fragment --><p>For propagate Cancellation, all async method recommend to accept <code>CancellationToken cancellationToken</code> at last argument, and pass <code>CancellationToken</code> from root to end.</p>
<div class="fragment"><div class="line">await FooAsync(this.GetCancellationTokenOnDestroy());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---</span></div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> FooAsync(CancellationToken cancellationToken)</div>
<div class="line">{</div>
<div class="line">    await BarAsync(cancellationToken);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> BarAsync(CancellationToken cancellationToken)</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3), cancellationToken);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>CancellationToken</code> means lifecycle of async. You can hold your own lifecycle insteadof default CancellationTokenOnDestroy.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyBehaviour : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    CancellationTokenSource disableCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    CancellationTokenSource destroyCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnEnable()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (disableCancellation != <span class="keyword">null</span>)</div>
<div class="line">        {</div>
<div class="line">            disableCancellation.Dispose();</div>
<div class="line">        }</div>
<div class="line">        disableCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDisable()</div>
<div class="line">    {</div>
<div class="line">        disableCancellation.Cancel();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDestroy()</div>
<div class="line">    {</div>
<div class="line">        destroyCancellation.Cancel();</div>
<div class="line">        destroyCancellation.Dispose();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After Unity 2022.2, Unity adds CancellationToken in <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour-destroyCancellationToken.html">MonoBehaviour.destroyCancellationToken</a> and <a href="https://docs.unity3d.com/ScriptReference/Application-exitCancellationToken.html">Application.exitCancellationToken</a>.</p>
<p>When cancellation is detected, all methods throw <code>OperationCanceledException</code> and propagate upstream. When exception(not limited to <code>OperationCanceledException</code>) is not handled in async method, it is propagated finally to <code>UniTaskScheduler.UnobservedTaskException</code>. The default behaviour of received unhandled exception is to write log as exception. Log level can be changed using <code>UniTaskScheduler.UnobservedExceptionWriteLogType</code>. If you want to use custom behaviour, set an action to <code>UniTaskScheduler.UnobservedTaskException.</code></p>
<p>And also <code>OperationCanceledException</code> is a special exception, this is silently ignored at <code>UnobservedTaskException</code>.</p>
<p>If you want to cancel behaviour in an async UniTask method, throw <code>OperationCanceledException</code> manually.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> FooAsync()</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> OperationCanceledException();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you handle an exception but want to ignore(propagate to global cancellation handling), use an exception filter.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> BarAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        var x = await FooAsync();</div>
<div class="line">        <span class="keywordflow">return</span> x * 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (Exception ex) when (!(ex is OperationCanceledException)) <span class="comment">// when (ex is not OperationCanceledException) at C# 9.0</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>throws/catch <code>OperationCanceledException</code> is slightly heavy, so if performance is a concern, use <code>UniTask.SuppressCancellationThrow</code> to avoid OperationCanceledException throw. It returns <code>(bool IsCanceled, T Result)</code> instead of throwing.</p>
<div class="fragment"><div class="line">var (isCanceled, _) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(10, cancellationToken: cts.Token).<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a5a46cd11ff7472238771e1967150acbd">SuppressCancellationThrow</a>();</div>
<div class="line"><span class="keywordflow">if</span> (isCanceled)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a5a46cd11ff7472238771e1967150acbd"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a5a46cd11ff7472238771e1967150acbd">Cysharp.Threading.Tasks.UniTask.SuppressCancellationThrow</a></div><div class="ttdeci">UniTask&lt; bool &gt; SuppressCancellationThrow()</div><div class="ttdoc">returns (bool IsCanceled) instead of throws OperationCanceledException.</div><div class="ttdef"><b>Definition</b> UniTask.cs:68</div></div>
</div><!-- fragment --><p>Note: Only suppress throws if you call directly into the most source method. Otherwise, the return value will be converted, but the entire pipeline will not suppress throws.</p>
<p>Some features that use Unity's player loop, such as <code>UniTask.Yield</code> and <code>UniTask.Delay</code> etc, determines CancellationToken state on the player loop. This means it does not cancel immediately upon <code>CancellationToken</code> fired.</p>
<p>If you want to change this behaviour, the cancellation to be immediate, set the <code>cancelImmediately</code> flag as an argument.</p>
<div class="fragment"><div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(cancellationToken, cancelImmediately: <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Note: Setting <code>cancelImmediately</code> to true and detecting an immediate cancellation is more costly than the default behavior. This is because it uses <code>CancellationToken.Register</code>; it is heavier than checking CancellationToken on the player loop.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Timeout handling</h1>
<p>Timeout is a variation of cancellation. You can set timeout by <code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code> and pass CancellationToken to async methods.</p>
<div class="fragment"><div class="line">var cts = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); <span class="comment">// 5sec timeout.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest().WithCancellation(cts.Token);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (ex.CancellationToken == cts.Token)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Timeout&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><code>CancellationTokenSouce.CancelAfter</code> is a standard api. However in Unity you should not use it because it depends threading timer. <code>CancelAfterSlim</code> is UniTask's extension methods, it uses PlayerLoop instead. </p>
</blockquote>
<p>If you want to use timeout with other source of cancellation, use <code>CancellationTokenSource.CreateLinkedTokenSource</code>.</p>
<div class="fragment"><div class="line">var cancelToken = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">cancelButton.onClick.AddListener(() =&gt;</div>
<div class="line">{</div>
<div class="line">    cancelToken.Cancel(); <span class="comment">// cancel from button click.</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">var timeoutToken = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); <span class="comment">// 5sec timeout.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// combine token</span></div>
<div class="line">    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);</div>
<div class="line"> </div>
<div class="line">    await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest().WithCancellation(linkedTokenSource.Token);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (timeoutToken.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Timeout.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cancelToken.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Cancel clicked.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Optimize for reduce allocation of CancellationTokenSource for timeout per call async method, you can use UniTask's <code>TimeoutController</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a> timeoutController = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a>(); <span class="comment">// setup to field for reuse.</span></div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> FooAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// you can pass timeoutController.Timeout(TimeSpan) to cancellationToken.</span></div>
<div class="line">        await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest()</div>
<div class="line">            .WithCancellation(timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#ad0b83419aa0ff4d43629cc44a61746d1">Timeout</a>(TimeSpan.FromSeconds(5)));</div>
<div class="line">        timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a660360e136262cb21ee507bfe3e82677">Reset</a>(); <span class="comment">// call Reset(Stop timeout timer and ready for reuse) when succeed.</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a83ef18b291adc1577249beb3561ecdef">IsTimeout</a>())</div>
<div class="line">        {</div>
<div class="line">            UnityEngine.Debug.Log(<span class="stringliteral">&quot;timeout&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">Cysharp.Threading.Tasks.TimeoutController</a></div><div class="ttdef"><b>Definition</b> TimeoutController.cs:15</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_a660360e136262cb21ee507bfe3e82677"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a660360e136262cb21ee507bfe3e82677">Cysharp.Threading.Tasks.TimeoutController.Reset</a></div><div class="ttdeci">void Reset()</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:100</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_a83ef18b291adc1577249beb3561ecdef"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a83ef18b291adc1577249beb3561ecdef">Cysharp.Threading.Tasks.TimeoutController.IsTimeout</a></div><div class="ttdeci">bool IsTimeout()</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:95</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_ad0b83419aa0ff4d43629cc44a61746d1"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#ad0b83419aa0ff4d43629cc44a61746d1">Cysharp.Threading.Tasks.TimeoutController.Timeout</a></div><div class="ttdeci">CancellationToken Timeout(int millisecondsTimeout)</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:51</div></div>
</div><!-- fragment --><p>If you want to use timeout with other source of cancellation, use <code>new TimeoutController(CancellationToken)</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a> timeoutController;</div>
<div class="line">CancellationTokenSource clickCancelSource;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    this.clickCancelSource = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    this.timeoutController = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a>(clickCancelSource);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: UniTask has <code>.Timeout</code>, <code>.TimeoutWithoutException</code> methods however, if possible, do not use these, please pass <code>CancellationToken</code>. Because <code>.Timeout</code> work from external of task, can not stop timeoutted task. <code>.Timeout</code> means ignore result when timeout. If you pass a <code>CancellationToken</code> to the method, it will act from inside of the task, so it is possible to stop a running task.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Progress</h1>
<p>Some async operations for unity have <code>ToUniTask(IProgress&lt;float&gt; progress = null, ...)</code> extension methods.</p>
<div class="fragment"><div class="line">var progress = <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Progress</a>.Create&lt;<span class="keywordtype">float</span>&gt;(x =&gt; <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x));</div>
<div class="line"> </div>
<div class="line">var request = await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>)</div>
<div class="line">    .SendWebRequest()</div>
<div class="line">    .ToUniTask(progress: progress);</div>
</div><!-- fragment --><p>You should not use standard <code>new System.Progress&lt;T&gt;</code>, because it causes allocation every time. Use <code><a class="el" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html" title="Lightweight IProgress[T] factory.">Cysharp.Threading.Tasks.Progress</a></code> instead. This progress factory has two methods, <code>Create</code> and <code>CreateOnlyValueChanged</code>. <code>CreateOnlyValueChanged</code> calls only when the progress value has changed.</p>
<p>Implementing IProgress interface to caller is better as there is no lambda allocation.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Foo : MonoBehaviour, IProgress&lt;float&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Report(<span class="keywordtype">float</span> value)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> WebRequest()</div>
<div class="line">    {</div>
<div class="line">        var request = await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>)</div>
<div class="line">            .SendWebRequest()</div>
<div class="line">            .ToUniTask(progress: <span class="keyword">this</span>); <span class="comment">// pass this</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
PlayerLoop</h1>
<p>UniTask is run on a custom <a href="https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoop.html">PlayerLoop</a>. UniTask's playerloop based methods (such as <code>Delay</code>, <code>DelayFrame</code>, <code>asyncOperation.ToUniTask</code>, etc...) accept this <code>PlayerLoopTiming</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a></div>
<div class="line">{</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4">Initialization</a> = 0,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45">LastInitialization</a> = 1,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5">EarlyUpdate</a> = 2,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b">LastEarlyUpdate</a> = 3,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e">FixedUpdate</a> = 4,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b">LastFixedUpdate</a> = 5,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c">PreUpdate</a> = 6,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283">LastPreUpdate</a> = 7,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6">Update</a> = 8,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8">LastUpdate</a> = 9,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754">PreLateUpdate</a> = 10,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73">LastPreLateUpdate</a> = 11,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef">PostLateUpdate</a> = 12,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726">LastPostLateUpdate</a> = 13</div>
<div class="line">    </div>
<div class="line"><span class="preprocessor">#if UNITY_2020_2_OR_NEWER</span></div>
<div class="line">    TimeUpdate = 14,</div>
<div class="line">    LastTimeUpdate = 15,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6">Cysharp.Threading.Tasks.PlayerLoopTiming.Update</a></div><div class="ttdeci">@ Update</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:85</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8">Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate</a></div><div class="ttdeci">@ LastUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:86</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5">Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate</a></div><div class="ttdeci">@ EarlyUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:76</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate</a></div><div class="ttdeci">@ LastPreUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:83</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45">Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization</a></div><div class="ttdeci">@ LastInitialization</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:74</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c">Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate</a></div><div class="ttdeci">@ PreUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:82</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef">Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate</a></div><div class="ttdeci">@ PostLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:91</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4">Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization</a></div><div class="ttdeci">@ Initialization</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:73</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b">Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate</a></div><div class="ttdeci">@ LastFixedUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:80</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate</a></div><div class="ttdeci">@ LastPreLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:89</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e">Cysharp.Threading.Tasks.PlayerLoopTiming.FixedUpdate</a></div><div class="ttdeci">@ FixedUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:79</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754">Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate</a></div><div class="ttdeci">@ PreLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:88</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPostLateUpdate</a></div><div class="ttdeci">@ LastPostLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:92</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b">Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate</a></div><div class="ttdeci">@ LastEarlyUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:77</div></div>
</div><!-- fragment --><p>It indicates when to run, you can check <a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">PlayerLoopList.md</a> to Unity's default playerloop and injected UniTask's custom loop.</p>
<p><code>PlayerLoopTiming.Update</code> is similar to <code>yield return null</code> in a coroutine, but it is called before Update(Update and uGUI events(button.onClick, etc...) are called on <code>ScriptRunBehaviourUpdate</code>, yield return null is called on <code>ScriptRunDelayedDynamicFrameRate</code>). <code>PlayerLoopTiming.FixedUpdate</code> is similar to <code>WaitForFixedUpdate</code>.</p>
<blockquote class="doxtable">
<p><code>PlayerLoopTiming.LastPostLateUpdate</code> is not equivalent to coroutine's <code>yield return new WaitForEndOfFrame()</code>. Coroutine's WaitForEndOfFrame seems to run after the PlayerLoop is done. Some methods that require coroutine's end of frame(<code>Texture2D.ReadPixels</code>, <code>ScreenCapture.CaptureScreenshotAsTexture</code>, <code>CommandBuffer</code>, etc) do not work correctly when replaced with async/await. In these cases, pass MonoBehaviour(coroutine runnner) to <code>UniTask.WaitForEndOfFrame</code>. For example, <code>await UniTask.WaitForEndOfFrame(this);</code> is lightweight allocation free alternative of <code>yield return new WaitForEndOfFrame()</code>.</p>
<p>Note: In Unity 2023.1 or newer, <code>await UniTask.WaitForEndOfFrame();</code> no longer requires MonoBehaviour. It uses <code>UnityEngine.Awaitable.EndOfFrameAsync</code>. </p>
</blockquote>
<p><code>yield return null</code> and <code>UniTask.Yield</code> are similar but different. <code>yield return null</code> always returns next frame but <code>UniTask.Yield</code> returns next called. That is, call <code>UniTask.Yield(PlayerLoopTiming.Update)</code> on <code>PreUpdate</code>, it returns same frame. <code>UniTask.NextFrame()</code> guarantees return next frame, you can expect this to behave exactly the same as <code>yield return null</code>.</p>
<blockquote class="doxtable">
<p>UniTask.Yield(without CancellationToken) is a special type, returns <code>YieldAwaitable</code> and runs on YieldRunner. It is the most lightweight and fastest. </p>
</blockquote>
<p><code>AsyncOperation</code> is returned from native timing. For example, await <code>SceneManager.LoadSceneAsync</code> is returned from <code>EarlyUpdate.UpdatePreloading</code> and after being called, the loaded scene's <code>Start</code> is called from <code>EarlyUpdate.ScriptRunDelayedStartupFrame</code>. Also <code>await UnityWebRequest</code> is returned from <code>EarlyUpdate.ExecuteMainThreadJobs</code>.</p>
<p>In UniTask, await directly uses native timing, while <code>WithCancellation</code> and <code>ToUniTask</code> use specified timing. This is usually not a particular problem, but with <code>LoadSceneAsync</code>, it causes a different order of Start and continuation after await. So it is recommended not to use <code>LoadSceneAsync.ToUniTask</code>.</p>
<blockquote class="doxtable">
<p>Note: When using Unity 2023.1 or newer, ensure you have <code>using UnityEngine;</code> in the using statements of your file when working with new <code>UnityEngine.Awaitable</code> methods like <code>SceneManager.LoadSceneAsync</code>. This prevents compilation errors by avoiding the use of the <code>UnityEngine.AsyncOperation</code> version. </p>
</blockquote>
<p>In the stacktrace, you can check where it is running in playerloop.</p>
<p><img src="https://user-images.githubusercontent.com/46207/83735571-83caea80-a68b-11ea-8d22-5e22864f0d24.png" alt="image" class="inline"/></p>
<p>By default, UniTask's PlayerLoop is initialized at <code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]</code>.</p>
<p>The order in which methods are called in BeforeSceneLoad is nondeterministic, so if you want to use UniTask in other BeforeSceneLoad methods, you should try to initialize it before this.</p>
<div class="fragment"><div class="line"><span class="comment">// AfterAssembliesLoaded is called before BeforeSceneLoad</span></div>
<div class="line">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> InitUniTaskLoop()</div>
<div class="line">{</div>
<div class="line">    var loop = PlayerLoop.GetCurrentPlayerLoop();</div>
<div class="line">    <a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.<a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref loop);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">Cysharp.Threading.Tasks.PlayerLoopHelper</a></div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:180</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper_html_a532d6a7102811d3e022a5c0afb83ceaa"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize</a></div><div class="ttdeci">static void Initialize(ref PlayerLoopSystem playerLoop, InjectPlayerLoopTimings injectTimings=InjectPlayerLoopTimings.All)</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:398</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_html"><div class="ttname"><a href="namespace_cysharp_1_1_threading.html">Cysharp.Threading</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
<div class="ttc" id="anamespace_cysharp_html"><div class="ttname"><a href="namespace_cysharp.html">Cysharp</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
</div><!-- fragment --><p>If you import Unity's <code>Entities</code> package, that resets the custom player loop to default at <code>BeforeSceneLoad</code> and injects ECS's loop. When Unity calls ECS's inject method after UniTask's initialize method, UniTask will no longer work.</p>
<p>To solve this issue, you can re-initialize the UniTask PlayerLoop after ECS is initialized.</p>
<div class="fragment"><div class="line"><span class="comment">// Get ECS Loop.</span></div>
<div class="line">var playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Setup UniTask&#39;s PlayerLoop.</span></div>
<div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref playerLoop);</div>
</div><!-- fragment --><p>You can diagnose whether UniTask's player loop is ready by calling <code>PlayerLoopHelper.IsInjectedUniTaskPlayerLoop()</code>. And also <code>PlayerLoopHelper.DumpCurrentPlayerLoop</code> logs all current playerloops to console.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    UnityEngine.Debug.Log(<span class="stringliteral">&quot;UniTaskPlayerLoop ready? &quot;</span> + <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.IsInjectedUniTaskPlayerLoop());</div>
<div class="line">    <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.DumpCurrentPlayerLoop();</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can optimize loop cost slightly by remove unuse PlayerLoopTiming injection. You can call <code>PlayerLoopHelper.Initialize(InjectPlayerLoopTimings)</code> on initialize.</p>
<div class="fragment"><div class="line">var loop = PlayerLoop.GetCurrentPlayerLoop();</div>
<div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref loop, <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a5ee78743c74d17fec9af7caec019a2f9">InjectPlayerLoopTimings</a>.Minimum); <span class="comment">// minimum is Update | FixedUpdate | LastPostLateUpdate</span></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a5ee78743c74d17fec9af7caec019a2f9"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a5ee78743c74d17fec9af7caec019a2f9">Cysharp.Threading.Tasks.InjectPlayerLoopTimings</a></div><div class="ttdeci">InjectPlayerLoopTimings</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:103</div></div>
</div><!-- fragment --><p><code>InjectPlayerLoopTimings</code> has three preset, <code>All</code> and <code>Standard</code>(All without last except LastPostLateUpdate), <code>Minimum</code>(<code>Update | FixedUpdate | LastPostLateUpdate</code>). Default is All and you can combine custom inject timings like <code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code>.</p>
<p>You can make error to use uninjected <code>PlayerLoopTiming</code> by <a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>. For example, you can setup <code>BannedSymbols.txt</code> like this for <code>InjectPlayerLoopTimings.Minimum</code>.</p>
<div class="fragment"><div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.Initialization; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.EarlyUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.d</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastFixedUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastPreUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.PreLateUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.PostLateUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastTimeUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
</div><!-- fragment --><p>You can configure <code>RS0030</code> severity to error.</p>
<p><img src="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png" alt="image" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md11"></a>
async void vs async UniTaskVoid</h1>
<p><code>async void</code> is a standard C# task system so it does not run on UniTask systems. It is better not to use it. <code>async UniTaskVoid</code> is a lightweight version of <code>async UniTask</code> because it does not have awaitable completion and reports errors immediately to <code>UniTaskScheduler.UnobservedTaskException</code>. If you don't require awaiting (fire and forget), using <code>UniTaskVoid</code> is better. Unfortunately to dismiss warning, you're required to call <code>Forget()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> FireAndForgetMethod()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do anything...</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Caller()</div>
<div class="line">{</div>
<div class="line">    FireAndForgetMethod().Forget();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Also UniTask has the <code>Forget</code> method, it is similar to <code>UniTaskVoid</code> and has the same effects. However <code>UniTaskVoid</code> is more efficient if you completely don't use <code>await</code>。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> DoAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do anything...</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Caller()</div>
<div class="line">{</div>
<div class="line">    DoAsync().Forget();</div>
<div class="line">}</div>
</div><!-- fragment --><p>To use an async lambda registered to an event, don't use <code>async void</code>. Instead you can use <code>UniTask.Action</code> or <code>UniTask.UnityAction</code>, both of which create a delegate via <code>async UniTaskVoid</code> lambda.</p>
<div class="fragment"><div class="line">Action actEvent;</div>
<div class="line">UnityAction unityEvent; <span class="comment">// especially used in uGUI</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad: async void</span></div>
<div class="line">actEvent += async () =&gt; { };</div>
<div class="line">unityEvent += async () =&gt; { };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Ok: create Action delegate by lambda</span></div>
<div class="line">actEvent += <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ae7caae6a6de30d3b9f0e36b554caf904">Action</a>(async () =&gt; { await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(); });</div>
<div class="line">unityEvent += <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.UnityAction(async () =&gt; { await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(); });</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_ae7caae6a6de30d3b9f0e36b554caf904"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ae7caae6a6de30d3b9f0e36b554caf904">Cysharp.Threading.Tasks.UniTask.Action</a></div><div class="ttdeci">static Action Action(Func&lt; UniTaskVoid &gt; asyncAction)</div><div class="ttdoc">helper of create add UniTaskVoid to delegate. For example: FooAction = UniTask.Action(async () =&gt; { /...</div><div class="ttdef"><b>Definition</b> UniTask.Factory.cs:137</div></div>
</div><!-- fragment --><p><code>UniTaskVoid</code> can also be used in MonoBehaviour's <code>Start</code> method.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Sample : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> Start()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// async init code.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
UniTaskTracker</h1>
<p>useful for checking (leaked) UniTasks. You can open tracker window in <code>Window -&gt; UniTask Tracker</code>.</p>
<p><img src="https://user-images.githubusercontent.com/46207/83527073-4434bf00-a522-11ea-86e9-3b3975b26266.png" alt="image" class="inline"/></p>
<ul>
<li>Enable AutoReload(Toggle) - Reload automatically.</li>
<li>Reload - Reload view.</li>
<li>GC.Collect - Invoke GC.Collect.</li>
<li>Enable Tracking(Toggle) - Start to track async/await UniTask. Performance impact: low.</li>
<li>Enable StackTrace(Toggle) - Capture StackTrace when task is started. Performance impact: high.</li>
</ul>
<p>UniTaskTracker is intended for debugging use only as enabling tracking and capturing stacktraces is useful but has a heavy performance impact. Recommended usage is to enable both tracking and stacktraces to find task leaks and to disable them both when done.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
External Assets</h1>
<p>By default, UniTask supports TextMeshPro(<code>BindTo(TMP_Text)</code> and <code>TMP_InputField</code> event extensions like standard uGUI <code>InputField</code>), DOTween(<code>Tween</code> as awaitable) and Addressables(<code>AsyncOperationHandle</code> and <code>AsyncOperationHandle&lt;T&gt;</code> as awaitable).</p>
<p>There are defined in separated asmdefs like <code>UniTask.TextMeshPro</code>, <code>UniTask.DOTween</code>, <code>UniTask.Addressables</code>.</p>
<p>TextMeshPro and Addressables support are automatically enabled when importing their packages from package manager. However for DOTween support, after importing from the <a href="https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676r">DOTWeen assets</a> and define the scripting define symbol <code>UNITASK_DOTWEEN_SUPPORT</code> to enable it.</p>
<div class="fragment"><div class="line"><span class="comment">// sequential</span></div>
<div class="line">await transform.DOMoveX(2, 10);</div>
<div class="line">await transform.DOMoveZ(5, 20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// parallel with cancellation</span></div>
<div class="line">var ct = this.GetCancellationTokenOnDestroy();</div>
<div class="line"> </div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(</div>
<div class="line">    transform.DOMoveX(10, 3).WithCancellation(ct),</div>
<div class="line">    transform.DOScale(10, 3).WithCancellation(ct));</div>
</div><!-- fragment --><p>DOTween support's default behaviour(<code>await</code>, <code>WithCancellation</code>, <code>ToUniTask</code>) awaits tween is killed. It works on both Complete(true/false) and Kill(true/false). But if you want to reuse tweens (<code>SetAutoKill(false)</code>), it does not work as expected. If you want to await for another timing, the following extension methods exist in Tween, <code>AwaitForComplete</code>, <code>AwaitForPause</code>, <code>AwaitForPlay</code>, <code>AwaitForRewind</code>, <code>AwaitForStepComplete</code>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
AsyncEnumerable and Async LINQ</h1>
<p>Unity 2020.2 supports C# 8.0 so you can use <code>await foreach</code>. This is the new Update notation in the async era.</p>
<div class="fragment"><div class="line"><span class="comment">// Unity 2020.2, C# 8.0</span></div>
<div class="line">await <span class="keywordflow">foreach</span> (var _ <span class="keywordflow">in</span> UniTaskAsyncEnumerable.EveryUpdate().WithCancellation(token))</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Update() &quot;</span> + Time.frameCount);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In a C# 7.3 environment, you can use the <code>ForEachAsync</code> method to work in almost the same way.</p>
<div class="fragment"><div class="line"><span class="comment">// C# 7.3(Unity 2018.3~)</span></div>
<div class="line">await UniTaskAsyncEnumerable.EveryUpdate().ForEachAsync(_ =&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Update() &quot;</span> + Time.frameCount);</div>
<div class="line">}, token);</div>
</div><!-- fragment --><p><code>UniTask.WhenEach</code> that is similar to .NET 9's <code>Task.WhenEach</code> can consume new way for await multiple tasks.</p>
<div class="fragment"><div class="line">await <span class="keywordflow">foreach</span> (var result <span class="keywordflow">in</span> <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.WhenEach(task1, task2, task3))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The result is of type WhenEachResult&lt;T&gt;.</span></div>
<div class="line">    <span class="comment">// It contains either `T Result` or `Exception Exception`.</span></div>
<div class="line">    <span class="comment">// You can check `IsCompletedSuccessfully` or `IsFaulted` to determine whether to access `.Result` or `.Exception`.</span></div>
<div class="line">    <span class="comment">// If you want to throw an exception when `IsFaulted` and retrieve the result when successful, use `GetResult()`.</span></div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(result.GetResult());</div>
<div class="line">}</div>
</div><!-- fragment --><p>UniTaskAsyncEnumerable implements asynchronous LINQ, similar to LINQ in <code>IEnumerable&lt;T&gt;</code> or Rx in <code>IObservable&lt;T&gt;</code>. All standard LINQ query operators can be applied to asynchronous streams. For example, the following code shows how to apply a Where filter to a button-click asynchronous stream that runs once every two clicks.</p>
<div class="fragment"><div class="line">await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).ForEachAsync(_ =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p>Fire and Forget style(for example, event handling), you can also use <code>Subscribe</code>.</p>
<div class="fragment"><div class="line">okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).Subscribe(_ =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p>Async LINQ is enabled when <code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks_1_1_linq.html">Cysharp.Threading.Tasks.Linq</a>;</code>, and <code>UniTaskAsyncEnumerable</code> is defined in <code>UniTask.Linq</code> asmdef.</p>
<p>It's closer to UniRx (Reactive Extensions), but UniTaskAsyncEnumerable is a pull-based asynchronous stream, whereas Rx was a push-based asynchronous stream. Note that although similar, the characteristics are different and the details behave differently along with them.</p>
<p><code>UniTaskAsyncEnumerable</code> is the entry point like <code>Enumerable</code>. In addition to the standard query operators, there are other generators for Unity such as <code>EveryUpdate</code>, <code>Timer</code>, <code>TimerFrame</code>, <code>Interval</code>, <code>IntervalFrame</code>, and <code>EveryValueChanged</code>. And also added additional UniTask original query operators like <code>Append</code>, <code>Prepend</code>, <code>DistinctUntilChanged</code>, <code>ToHashSet</code>, <code>Buffer</code>, <code>CombineLatest</code>,<code>Merge</code> <code>Do</code>, <code>Never</code>, <code>ForEachAsync</code>, <code>Pairwise</code>, <code>Publish</code>, <code>Queue</code>, <code>Return</code>, <code>SkipUntil</code>, <code>TakeUntil</code>, <code>SkipUntilCanceled</code>, <code>TakeUntilCanceled</code>, <code>TakeLast</code>, <code>Subscribe</code>.</p>
<p>The method with Func as an argument has three additional overloads, <code>***Await</code>, <code>***AwaitWithCancellation</code>.</p>
<div class="fragment"><div class="line">Select(Func&lt;T, TR&gt; selector)</div>
<div class="line">SelectAwait(Func&lt;T, <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;TR&gt;</a>&gt; selector)</div>
<div class="line">SelectAwaitWithCancellation(Func&lt;T, CancellationToken, <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;TR&gt;</a>&gt; selector)</div>
</div><!-- fragment --><p>If you want to use the <code>async</code> method inside the func, use the <code>***Await</code> or <code>***AwaitWithCancellation</code>.</p>
<p>How to create an async iterator: C# 8.0 supports async iterator(<code>async yield return</code>) but it only allows <code>IAsyncEnumerable&lt;T&gt;</code> and of course requires C# 8.0. UniTask supports <code>UniTaskAsyncEnumerable.Create</code> method to create custom async iterator.</p>
<div class="fragment"><div class="line"><span class="comment">// IAsyncEnumerable, C# 8.0 version of async iterator. ( do not use this style, IAsyncEnumerable is not controled in UniTask).</span></div>
<div class="line"><span class="keyword">public</span> async IAsyncEnumerable&lt;int&gt; MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = <span class="keywordflow">default</span>)</div>
<div class="line">{</div>
<div class="line">    var frameCount = 0;</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    <span class="keywordflow">while</span> (!token.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        yield <span class="keywordflow">return</span> frameCount++;</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UniTaskAsyncEnumerable.Create and use `await writer.YieldAsync` instead of `yield return`.</span></div>
<div class="line"><span class="keyword">public</span> IUniTaskAsyncEnumerable&lt;int&gt; MyEveryUpdate()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// writer(IAsyncWriter&lt;T&gt;) has `YieldAsync(value)` method.</span></div>
<div class="line">    <span class="keywordflow">return</span> UniTaskAsyncEnumerable.Create&lt;<span class="keywordtype">int</span>&gt;(async (writer, token) =&gt;</div>
<div class="line">    {</div>
<div class="line">        var frameCount = 0;</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">        <span class="keywordflow">while</span> (!token.IsCancellationRequested)</div>
<div class="line">        {</div>
<div class="line">            await writer.YieldAsync(frameCount++); <span class="comment">// instead of `yield return`</span></div>
<div class="line">            await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Awaitable Events</h1>
<p>All uGUI component implements <code>***AsAsyncEnumerable</code> to convert asynchronous streams of events.</p>
<div class="fragment"><div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// In default, used button.GetCancellationTokenOnDestroy to manage lieftime of async</span></div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// more efficient way</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> (var handler = button.GetAsyncClickEventHandler())</div>
<div class="line">    {</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// use async LINQ</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick(CancellationToken token)</div>
<div class="line">{</div>
<div class="line">    await button.OnClickAsAsyncEnumerable().Take(3).Last();</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// use async LINQ2</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick(CancellationToken token)</div>
<div class="line">{</div>
<div class="line">    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&gt;</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Every clicked&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked, complete.&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>All MonoBehaviour message events can convert async-streams by <code>AsyncTriggers</code> that can be enabled by <code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks_1_1_triggers.html">Cysharp.Threading.Tasks.Triggers</a>;</code>. AsyncTrigger can be created using <code>GetAsync***Trigger</code> and triggers itself as UniTaskAsyncEnumerable.</p>
<div class="fragment"><div class="line">var trigger = this.GetOnCollisionEnterAsyncHandler();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// every moves.</span></div>
<div class="line">await this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p><code>AsyncReactiveProperty</code>, <code>AsyncReadOnlyReactiveProperty</code> is UniTask's version of ReactiveProperty. <code>BindTo</code> extension method of <code>IUniTaskAsyncEnumerable&lt;T&gt;</code> for binding asynchronous stream values to Unity components(Text/Selectable/TMP/Text).</p>
<div class="fragment"><div class="line">var rp = <span class="keyword">new</span> AsyncReactiveProperty&lt;int&gt;(99);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// AsyncReactiveProperty itself is IUniTaskAsyncEnumerable, you can query by LINQ</span></div>
<div class="line">rp.ForEachAsync(x =&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x);</div>
<div class="line">}, this.GetCancellationTokenOnDestroy()).Forget();</div>
<div class="line"> </div>
<div class="line">rp.Value = 10; <span class="comment">// push 10 to all subscriber</span></div>
<div class="line">rp.Value = 11; <span class="comment">// push 11 to all subscriber</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// WithoutCurrent ignore initial value</span></div>
<div class="line"><span class="comment">// BindTo bind stream value to unity components.</span></div>
<div class="line">rp.WithoutCurrent().BindTo(this.textComponent);</div>
<div class="line"> </div>
<div class="line">await rp.WaitAsync(); <span class="comment">// wait until next value set</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// also exists ToReadOnlyAsyncReactiveProperty</span></div>
<div class="line">var rp2 = <span class="keyword">new</span> AsyncReactiveProperty&lt;int&gt;(99);</div>
<div class="line">var rorp = rp.CombineLatest(rp2, (x, y) =&gt; (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);</div>
</div><!-- fragment --><p>A pull-type asynchronous stream does not get the next values until the asynchronous processing in the sequence is complete. This could spill data from push-type events such as buttons.</p>
<div class="fragment"><div class="line"><span class="comment">// can not get click event during 3 seconds complete.</span></div>
<div class="line">await button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><p>It is useful (prevent double-click) but not useful sometimes.</p>
<p>Using the <code>Queue()</code> method will also queue events during asynchronous processing.</p>
<div class="fragment"><div class="line"><span class="comment">// queued message in asynchronous processing</span></div>
<div class="line">await button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><p>Or use <code>Subscribe</code>, fire and forget style.</p>
<div class="fragment"><div class="line">button.OnClickAsAsyncEnumerable().Subscribe(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Channel</h1>
<p><code>Channel</code> is the same as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels?view=netcore-3.1">System.Threading.Tasks.Channels</a> which is similar to a GoLang Channel.</p>
<p>Currently it only supports multiple-producer, single-consumer unbounded channels. It can create by <code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;()</code>.</p>
<p>For producer(<code>.Writer</code>), use <code>TryWrite</code> to push value and <code>TryComplete</code> to complete channel. For consumer(<code>.Reader</code>), use <code>TryRead</code>, <code>WaitToReadAsync</code>, <code>ReadAsync</code>, <code>Completion</code> and <code>ReadAllAsync</code> to read queued messages.</p>
<p><code>ReadAllAsync</code> returns <code>IUniTaskAsyncEnumerable&lt;T&gt;</code> so query LINQ operators. Reader only allows single-consumer but uses <code>.Publish()</code> query operator to enable multicast message. For example, make pub/sub utility.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>AsyncMessageBroker&lt;T&gt; : IDisposable</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Channel&lt;T&gt;</a> channel;</div>
<div class="line"> </div>
<div class="line">    IConnectableUniTaskAsyncEnumerable&lt;T&gt; multicastSource;</div>
<div class="line">    IDisposable connection;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> AsyncMessageBroker()</div>
<div class="line">    {</div>
<div class="line">        channel = <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Channel</a>.CreateSingleConsumerUnbounded&lt;T&gt;();</div>
<div class="line">        multicastSource = channel.Reader.ReadAllAsync().Publish();</div>
<div class="line">        connection = multicastSource.Connect(); <span class="comment">// Publish returns IConnectableUniTaskAsyncEnumerable.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Publish(T value)</div>
<div class="line">    {</div>
<div class="line">        channel.Writer.TryWrite(value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> IUniTaskAsyncEnumerable&lt;T&gt; Subscribe()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> multicastSource;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Dispose()</div>
<div class="line">    {</div>
<div class="line">        channel.Writer.TryComplete();</div>
<div class="line">        connection.Dispose();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_channel_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Cysharp.Threading.Tasks.Channel</a></div><div class="ttdef"><b>Definition</b> Channel.cs:8</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
vs Awaitable</h1>
<p>Unity 6 introduces the awaitable type, <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Awaitable.html">Awaitable</a>. To put it simply, Awaitable can be considered a subset of UniTask, and in fact, Awaitable's design was influenced by UniTask. It should be able to handle PlayerLoop-based awaits, pooled Tasks, and support for cancellation with <code>CancellationToken</code> in a similar way. With its inclusion in the standard library, you may wonder whether to continue using UniTask or migrate to Awaitable. Here's a brief guide.</p>
<p>First, the functionality provided by Awaitable is equivalent to what coroutines offer. Instead of <code>yield return</code>, you use await; <code>await NextFrameAsync()</code> replaces <code>yield return null</code>; and there are equivalents for <code>WaitForSeconds</code> and <code>EndOfFrame</code>. However, that's the extent of it. Being coroutine-based in terms of functionality, it lacks Task-based features. In practical application development using async/await, operations like <code>WhenAll</code> are essential. Additionally, UniTask enables many frame-based operations (such as <code>DelayFrame</code>) and more flexible PlayerLoopTiming control, which are not available in Awaitable. Of course, there's no Tracker Window either.</p>
<p>Therefore, I recommend using UniTask for application development. UniTask is a superset of Awaitable and includes many essential features. For library development, where you want to avoid external dependencies, using Awaitable as a return type for methods would be appropriate. Awaitable can be converted to UniTask using <code>AsUniTask</code>, so there's no issue in handling Awaitable-based functionality within the UniTask library. Of course, if you don't need to worry about dependencies, using UniTask would be the best choice even for library development.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
For Unit Testing</h1>
<p>Unity's <code>[UnityTest]</code> attribute can test coroutine(IEnumerator) but can not test async. <code>UniTask.ToCoroutine</code> bridges async/await to coroutine so you can test async methods.</p>
<div class="fragment"><div class="line">[UnityTest]</div>
<div class="line"><span class="keyword">public</span> IEnumerator DelayIgnore() =&gt; <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a2b4f9a504e35fcfca8a33029931cc393">ToCoroutine</a>(async () =&gt;</div>
<div class="line">{</div>
<div class="line">    var time = Time.realtimeSinceStartup;</div>
<div class="line"> </div>
<div class="line">    Time.timeScale = 0.5f;</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3), ignoreTimeScale: <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        var elapsed = Time.realtimeSinceStartup - time;</div>
<div class="line">        <a class="code hl_typedef" href="_scene_test_fixture_8cs.html#af7550d85bc26da18b3dd7647bc12d577">Assert</a>.AreEqual(3, (<span class="keywordtype">int</span>)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">finally</span></div>
<div class="line">    {</div>
<div class="line">        Time.timeScale = 1.0f;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="a_scene_test_fixture_8cs_html_af7550d85bc26da18b3dd7647bc12d577"><div class="ttname"><a href="_scene_test_fixture_8cs.html#af7550d85bc26da18b3dd7647bc12d577">Assert</a></div><div class="ttdeci">ModestTree.Assert Assert</div><div class="ttdef"><b>Definition</b> SceneTestFixture.cs:9</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a2b4f9a504e35fcfca8a33029931cc393"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a2b4f9a504e35fcfca8a33029931cc393">Cysharp.Threading.Tasks.UniTask.ToCoroutine</a></div><div class="ttdeci">static IEnumerator ToCoroutine(Func&lt; UniTask &gt; taskFactory)</div><div class="ttdef"><b>Definition</b> UniTask.Bridge.cs:12</div></div>
</div><!-- fragment --><p>UniTask's own unit tests are written using Unity Test Runner and <a href="https://github.com/Cysharp/RuntimeUnitTestToolkit">Cysharp/RuntimeUnitTestToolkit</a> to integrate with CI and check if IL2CPP is working.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
ThreadPool limitation</h1>
<p>Most UniTask methods run on a single thread (PlayerLoop), with only <code>UniTask.Run</code>(<code>Task.Run</code> equivalent) and <code>UniTask.SwitchToThreadPool</code> running on a thread pool. If you use a thread pool, it won't work with WebGL and so on.</p>
<p><code>UniTask.Run</code> is now deprecated. You can use <code>UniTask.RunOnThreadPool</code> instead. And also consider whether you can use <code>UniTask.Create</code> or <code>UniTask.Void</code>.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
IEnumerator.ToUniTask limitation</h1>
<p>You can convert coroutine(IEnumerator) to UniTask(or await directly) but it has some limitations.</p>
<ul>
<li><code>WaitForEndOfFrame</code>/<code>WaitForFixedUpdate</code>/<code>Coroutine</code> is not supported.</li>
<li>Consuming loop timing is not the same as <code>StartCoroutine</code>, it uses the specified <code>PlayerLoopTiming</code> and the default <code>PlayerLoopTiming.Update</code> is run before MonoBehaviour's <code>Update</code> and <code>StartCoroutine</code>'s loop.</li>
</ul>
<p>If you want fully compatible conversion from coroutine to async, use the <code>IEnumerator.ToUniTask(MonoBehaviour coroutineRunner)</code> overload. It executes StartCoroutine on an instance of the argument MonoBehaviour and waits for it to complete in UniTask.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
For UnityEditor</h1>
<p>UniTask can run on Unity Editor like an Editor Coroutine. However, there are some limitations.</p>
<ul>
<li>UniTask.Delay's DelayType.DeltaTime, UnscaledDeltaTime do not work correctly because they can not get deltaTime in editor. Therefore run on EditMode, automatically change DelayType to <code>DelayType.Realtime</code> that wait for the right time.</li>
<li>All PlayerLoopTiming run on the timing <code>EditorApplication.update</code>.</li>
<li><code>-batchmode</code> with <code>-quit</code> does not work because Unity does not run <code>EditorApplication.update</code> and quit after a single frame. Instead, don't use <code>-quit</code> and quit manually with <code>EditorApplication.Exit(0)</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Compare with Standard Task API</h1>
<p>UniTask has many standard Task-like APIs. This table shows what the alternative apis are.</p>
<p>Use standard type.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">.NET Type   </th><th class="markdownTableHeadNone">UniTask Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IProgress&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">&mdash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CancellationToken</code>   </td><td class="markdownTableBodyNone">&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>CancellationTokenSource</code>   </td><td class="markdownTableBodyNone">&mdash;   </td></tr>
</table>
<p>Use UniTask type.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">.NET Type   </th><th class="markdownTableHeadNone">UniTask Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task</code>/<code>ValueTask</code>   </td><td class="markdownTableBodyNone"><code>UniTask</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task&lt;T&gt;</code>/<code>ValueTask&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTask&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>async void</code>   </td><td class="markdownTableBodyNone"><code>async UniTaskVoid</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+= async () =&gt; { }</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Void</code>, <code>UniTask.Action</code>, <code>UniTask.UnityAction</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&mdash;   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSource</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TaskCompletionSource&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSource&lt;T&gt;</code>/<code>AutoResetUniTaskCompletionSource&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ManualResetValueTaskSourceCore&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSourceCore&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IValueTaskSource</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskSource</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IValueTaskSource&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskSource&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ValueTask.IsCompleted</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Status.IsCompleted()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ValueTask&lt;T&gt;.IsCompleted</code>   </td><td class="markdownTableBodyNone"><code>UniTask&lt;T&gt;.Status.IsCompleted()</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>new Progress&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>Progress.Create&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>CancellationToken.Register(UnsafeRegister)</code>   </td><td class="markdownTableBodyNone"><code>CancellationToken.RegisterWithoutCaptureExecutionContext</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CancellationTokenSource.CancelAfter</code>   </td><td class="markdownTableBodyNone"><code>CancellationTokenSource.CancelAfterSlim</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Channel.CreateUnbounded&lt;T&gt;(false){ SingleReader = true }</code>   </td><td class="markdownTableBodyNone"><code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IAsyncEnumerable&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncEnumerable&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IAsyncEnumerator&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncEnumerator&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IAsyncDisposable</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncDisposable</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.Delay</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Delay</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.Yield</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Yield</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.Run</code>   </td><td class="markdownTableBodyNone"><code>UniTask.RunOnThreadPool</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.WhenAll</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenAll</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.WhenAny</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenAny</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.WhenEach</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenEach</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.CompletedTask</code>   </td><td class="markdownTableBodyNone"><code>UniTask.CompletedTask</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.FromException</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromException</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.FromResult</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromResult</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.FromCanceled</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromCanceled</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.ContinueWith</code>   </td><td class="markdownTableBodyNone"><code>UniTask.ContinueWith</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TaskScheduler.UnobservedTaskException</code>   </td><td class="markdownTableBodyNone"><code>UniTaskScheduler.UnobservedTaskException</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md23"></a>
Pooling Configuration</h1>
<p>UniTask aggressively caches async promise objects to achieve zero allocation (for technical details, see blog post <a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Zero Allocation async/await for Unity, with Asynchronous LINQ</a>). By default, it caches all promises but you can configure <code>TaskPool.SetMaxPoolSize</code> to your value, the value indicates cache size per type. <code>TaskPool.GetCacheSizeInfo</code> returns currently cached objects in pool.</p>
<div class="fragment"><div class="line"><span class="keywordflow">foreach</span> (var (type, size) in <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html">TaskPool</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html#ab8f77b900432b83101fda16d4ecfbb41">GetCacheSizeInfo</a>())</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(type + <span class="stringliteral">&quot;:&quot;</span> + size);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_task_pool_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html">Cysharp.Threading.Tasks.TaskPool</a></div><div class="ttdef"><b>Definition</b> TaskPool.cs:13</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_task_pool_html_ab8f77b900432b83101fda16d4ecfbb41"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html#ab8f77b900432b83101fda16d4ecfbb41">Cysharp.Threading.Tasks.TaskPool.GetCacheSizeInfo</a></div><div class="ttdeci">static IEnumerable&lt;(Type, int)&gt; GetCacheSizeInfo()</div><div class="ttdef"><b>Definition</b> TaskPool.cs:43</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Allocation on Profiler</h1>
<p>In UnityEditor the profiler shows allocation of compiler generated AsyncStateMachine but it only occurs in debug(development) build. C# Compiler generates AsyncStateMachine as class on <a class="el" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a> build and as struct on Release build.</p>
<p>Unity supports Code Optimization option starting in 2020.1 (right, footer).</p>
<p><img src="https://user-images.githubusercontent.com/46207/89967342-2f944600-dc8c-11ea-99fc-0b74527a16f6.png" alt="" class="inline"/></p>
<p>You can change C# compiler optimization to release to remove AsyncStateMachine allocation in development builds. This optimization option can also be set via <code>Compilation.CompilationPipeline-codeOptimization</code>, and <code>Compilation.CodeOptimization</code>.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
UniTaskSynchronizationContext</h1>
<p>Unity's default SynchronizationContext(<code>UnitySynchronizationContext</code>) is a poor implementation for performance. UniTask bypasses <code>SynchronizationContext</code>(and <code>ExecutionContext</code>) so it does not use it but if exists in <code>async Task</code>, still used it. <code>UniTaskSynchronizationContext</code> is a replacement of <code>UnitySynchronizationContext</code> which is better for performance.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>SyncContextInjecter</div>
<div class="line">{</div>
<div class="line">    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> Inject()</div>
<div class="line">    {</div>
<div class="line">        SynchronizationContext.SetSynchronizationContext(<span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context.html">UniTaskSynchronizationContext</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context.html">Cysharp.Threading.Tasks.UniTaskSynchronizationContext</a></div><div class="ttdef"><b>Definition</b> UniTaskSynchronizationContext.cs:8</div></div>
</div><!-- fragment --><p>This is an optional choice and is not always recommended; <code>UniTaskSynchronizationContext</code> is less performant than <code>async UniTask</code> and is not a complete UniTask replacement. It also does not guarantee full behavioral compatibility with the <code>UnitySynchronizationContext</code>.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
API References</h1>
<p>UniTask's API References are hosted at <a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.html">cysharp.github.io/UniTask</a> by <a href="https://dotnet.github.io/docfx/">DocFX</a> and <a href="https://github.com/Cysharp/DocfxTemplate">Cysharp/DocfXTemplate</a>.</p>
<p>For example, UniTask's factory methods can be seen at <a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.UniTask.html#methods-1">UniTask#methods</a>. UniTaskAsyncEnumerable's factory/extension methods can be seen at <a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.html#methods-1">UniTaskAsyncEnumerable#methods</a>.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
UPM Package</h1>
<h2><a class="anchor" id="autotoc_md28"></a>
Install via git URL</h2>
<p>Requires a version of unity that supports path query parameter for git packages (Unity &gt;= 2019.3.4f1, Unity &gt;= 2020.1a21). You can add <code><a href="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask">https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</a></code> to Package Manager</p>
<p><img src="https://user-images.githubusercontent.com/46207/79450714-3aadd100-8020-11ea-8aae-b8d87fc4d7be.png" alt="image" class="inline"/></p>
<p><img src="https://user-images.githubusercontent.com/46207/83702872-e0f17c80-a648-11ea-8183-7469dcd4f810.png" alt="image" class="inline"/></p>
<p>or add <code>"com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask"</code> to <code>Packages/manifest.json</code>.</p>
<p>If you want to set a target version, UniTask uses the <code>*.*.*</code> release tag so you can specify a version like <code>#2.1.0</code>. For example <code><a href="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask">https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</a>#2.1.0</code>.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
.NET Core</h1>
<p>For .NET Core, use NuGet.</p>
<blockquote class="doxtable">
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/UniTask">UniTask</a> </p>
</blockquote>
<p>UniTask of .NET Core version is a subset of Unity UniTask with PlayerLoop dependent methods removed.</p>
<p>It runs at higher performance than the standard Task/ValueTask, but you should be careful to ignore the ExecutionContext/SynchronizationContext when using it. <code>AsyncLocal</code> also does not work because it ignores ExecutionContext.</p>
<p>If you use UniTask internally, but provide ValueTask as an external API, you can write it like the following(Inspired by <a href="https://github.com/mgravell/PooledAwait">PooledAwait</a>).</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>ZeroAllocAsyncAwaitInDotNetCore</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> ValueTask&lt;int&gt; DoAsync(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> Core(<span class="keyword">this</span>, x, y);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">static</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> Core(ZeroAllocAsyncAwaitInDotNetCore <span class="keyword">self</span>, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// do anything...</span></div>
<div class="line">            await Task.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(x + y));</div>
<div class="line">            await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span> 10;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UniTask does not return to original SynchronizationContext but you can use helper `ReturnToCurrentSynchronizationContext`.</span></div>
<div class="line"><span class="keyword">public</span> ValueTask TestAsync()</div>
<div class="line">{</div>
<div class="line">    await <span class="keyword">using</span> (<a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#acfecddee7d437727fa79345759fbb880">ReturnToCurrentSynchronizationContext</a>())</div>
<div class="line">    {</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">SwitchToThreadPool</a>();</div>
<div class="line">        <span class="comment">// do anything..</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_acfecddee7d437727fa79345759fbb880"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#acfecddee7d437727fa79345759fbb880">Cysharp.Threading.Tasks.UniTask.ReturnToCurrentSynchronizationContext</a></div><div class="ttdeci">static ReturnToSynchronizationContext ReturnToCurrentSynchronizationContext(bool dontPostWhenSameContext=true, CancellationToken cancellationToken=default)</div><div class="ttdef"><b>Definition</b> UniTask.Threading.cs:81</div></div>
</div><!-- fragment --><p>.NET Core version is intended to allow users to use UniTask as an interface when sharing code with Unity (such as <a href="https://github.com/Cysharp/MagicOnion/">Cysharp/MagicOnion</a>). .NET Core version of UniTask enables smooth code sharing.</p>
<p>Utility methods such as WhenAll which are equivalent to UniTask are provided as <a href="https://github.com/Cysharp/ValueTaskSupplement">Cysharp/ValueTaskSupplement</a>.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
License</h1>
<p>This library is under the MIT License. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_84bbf7b3c7f28a5a18725745e1505219.html">Assets</a></li><li class="navelem"><a class="el" href="dir_eb5611cd5dd5e4191b2388e35f4d02f6.html">COREToolkit</a></li><li class="navelem"><a class="el" href="dir_513335de0e7c37c64b906a5db36262bf.html">ThirdParty</a></li><li class="navelem"><a class="el" href="dir_cc07ba466439861cfd52aac34bdc26ee.html">UniTask</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
