<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CORE Game Developers Toolkit: UniTask</title>
<link rel="icon" href="CoreLogoSmall.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="CoreLogoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">CORE Game Developers Toolkit<span id="projectnumber">&#160;v1.0.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__f_1_2_unity_projects_2_unity6_2_c_o_r_e_game_developers_toolkit___build_in_2_assets_2_c_o_r_8686625fbaab51b629e49ad54cb50463.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">UniTask</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/Cysharp/UniTask/actions"><img src="https://github.com/Cysharp/UniTask/workflows/Build-Debug/badge.svg" alt="GitHub Actions" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/Cysharp/UniTask/releases"><img src="https://img.shields.io/github/release/Cysharp/UniTask.svg" alt="Releases" style="pointer-events: none;" class="inline"/></a></p>
<p>为Unity提供一个高性能，零堆内存分配的 async/await 异步方案。</p>
<ul>
<li>基于值类型的<code>UniTask&lt;T&gt;</code>和自定义的 AsyncMethodBuilder 来实现零堆内存分配</li>
<li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待</li>
<li>基于 PlayerLoop 的任务（<code>UniTask.Yield</code>，<code>UniTask.Delay</code>，<code>UniTask.DelayFrame</code>等..）可以替换所有协程操作</li>
<li>对 MonoBehaviour 消息事件和 uGUI 事件进行可等待/异步枚举扩展</li>
<li>完全在 Unity 的 PlayerLoop 上运行，因此不使用Thread，并且同样能在 WebGL、wasm 等平台上运行。</li>
<li>带有 Channel 和 AsyncReactiveProperty 的异步 LINQ</li>
<li>提供一个 TaskTracker EditorWindow 以追踪所有 UniTask 分配来预防内存泄漏</li>
<li>与原生 Task/ValueTask/IValueTaskSource 高度兼容的行为</li>
</ul>
<p>有关技术细节，请参阅博客文章：<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — 适用于 Unity 的零堆内存分配的async/await，支持异步 LINQ</a> <br  />
 有关高级技巧，请参阅博客文章：<a href="https://medium.com/@neuecc/extends-unitywebrequest-via-async-decorator-pattern-advanced-techniques-of-unitask-ceff9c5ee846">通过异步装饰器模式扩展 UnityWebRequest — UniTask 的高级技术</a></p>
<h1><a class="anchor" id="autotoc_md31"></a>
目录</h1>
<ul>
<li>入门</li>
<li>UniTask 和 AsyncOperation 的基础知识</li>
<li>取消和异常处理</li>
<li>超时处理</li>
<li>进度</li>
<li>PlayerLoop</li>
<li>async void 与 async UniTaskVoid 对比</li>
<li>UniTaskTracker</li>
<li>外部拓展</li>
<li>AsyncEnumerable 和 Async LINQ</li>
<li>可等待事件</li>
<li>Channel</li>
<li>与 Awaitable 对比</li>
<li>单元测试</li>
<li>线程池的限制</li>
<li>IEnumerator.ToUniTask 的限制</li>
<li>关于 UnityEditor</li>
<li>与原生 Task API 对比</li>
<li>池化配置</li>
<li>Profiler 下的堆内存分配</li>
<li>UniTaskSynchronizationContext</li>
<li>API 文档</li>
<li>UPM 包</li>
<li>通过 git URL 安装</li>
<li>关于 .NET Core</li>
<li>许可证</li>
</ul>
<h1><a class="anchor" id="autotoc_md32"></a>
入门</h1>
<p>通过<a href="https://github.com/Cysharp/UniTask/releases">UniTask/releases</a>页面中提供的<a href="https://github.com/Cysharp/UniTask#upm-package">UPM 包</a>或资产包（<code>UniTask.*.*.*.unitypackage</code>）安装。</p>
<div class="fragment"><div class="line"><span class="comment">// 使用 UniTask 所需的命名空间</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 您可以返回一个形如 UniTask&lt;T&gt;(或 UniTask) 的类型，这种类型事为Unity定制的，作为替代原生 Task&lt;T&gt; 的轻量级方案</span></div>
<div class="line"><span class="comment">// 为 Unity 集成的零堆内存分配，快速调用，0消耗的 async/await 方案</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;string&gt;</a> DemoAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 您可以等待一个 Unity 异步对象</span></div>
<div class="line">    var asset = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">    var txt = (await UnityWebRequest.Get(<span class="stringliteral">&quot;https://...&quot;</span>).SendWebRequest()).downloadHandler.text;</div>
<div class="line">    await SceneManager.LoadSceneAsync(<span class="stringliteral">&quot;scene2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// .WithCancellation 会启用取消功能，GetCancellationTokenOnDestroy 表示获取一个依赖对象生命周期的 Cancel 句柄，当对象被销毁时，将会调用这个 Cancel 句柄，从而实现取消的功能</span></div>
<div class="line">    <span class="comment">// 在 Unity 2022.2之后，您可以在 MonoBehaviour 中使用`destroyCancellationToken`</span></div>
<div class="line">    var asset2 = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;bar&quot;</span>).WithCancellation(this.GetCancellationTokenOnDestroy());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// .ToUniTask 可接收一个 progress 回调以及一些配置参数，Progress.Create 是 IProgress&lt;T&gt; 的轻量级替代方案</span></div>
<div class="line">    var asset3 = await Resources.LoadAsync&lt;TextAsset&gt;(<span class="stringliteral">&quot;baz&quot;</span>).ToUniTask(<a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Progress</a>.Create&lt;<span class="keywordtype">float</span>&gt;(x =&gt; <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x)));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 等待一个基于帧的延时操作（就像一个协程一样）</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(100); </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// yield return new WaitForSeconds/WaitForSecondsRealtime 的替代方案</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(10), ignoreTimeScale: <span class="keyword">false</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 可以等待任何 playerloop 的生命周期（PreUpdate，Update，LateUpdate等）</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(<a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a>.PreLateUpdate);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// yield return null 的替代方案</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#aaf67b3510a5a7421126aab2c31855408">NextFrame</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WaitForEndOfFrame 的替代方案</span></div>
<div class="line"><span class="preprocessor">#if UNITY_2023_1_OR_NEWER</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">WaitForEndOfFrame</a>();</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// 需要 MonoBehaviour（CoroutineRunner）</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">WaitForEndOfFrame</a>(<span class="keyword">this</span>); <span class="comment">// this是一个 MonoBehaviour</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// yield return new WaitForFixedUpdate 的替代方案，（等同于 UniTask.Yield(PlayerLoopTiming.FixedUpdate)）</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a64a8a0cd199604c90d89a8e88160eb80">WaitForFixedUpdate</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// yield return WaitUntil 的替代方案</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a185785658b777347c3eb9480a9dc8068">WaitUntil</a>(() =&gt; isActive == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WaitUntil 扩展，指定某个值改变时触发</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.WaitUntilValueChanged(<span class="keyword">this</span>, x =&gt; x.isActive);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 您可以直接 await 一个 IEnumerator 协程</span></div>
<div class="line">    await FooCoroutineEnumerator();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 您可以直接 await 一个原生 task</span></div>
<div class="line">    await Task.Run(() =&gt; 100);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 多线程示例，在此行代码后的内容都运行在一个线程池上</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">SwitchToThreadPool</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* 工作在线程池上的代码 */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 转回主线程（等同于 UniRx 的`ObserveOnMainThread`）</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.SwitchToMainThread();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 获取异步的 webrequest</span></div>
<div class="line">    async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;string&gt;</a> GetTextAsync(UnityWebRequest req)</div>
<div class="line">    {</div>
<div class="line">        var op = await req.SendWebRequest();</div>
<div class="line">        <span class="keywordflow">return</span> op.downloadHandler.text;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    var task1 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.com&quot;</span>));</div>
<div class="line">    var task2 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://bing.com&quot;</span>));</div>
<div class="line">    var task3 = GetTextAsync(UnityWebRequest.Get(<span class="stringliteral">&quot;http://yahoo.com&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 构造一个 async-wait，并通过元组语义轻松获取所有结果</span></div>
<div class="line">    var (google, bing, yahoo) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(task1, task2, task3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WhenAll 的简写形式，元组可以直接 await</span></div>
<div class="line">    var (google2, bing2, yahoo2) = await (task1, task2, task3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 返回一个异步值，或者您也可以使用`UniTask`（无结果），`UniTaskVoid`（不可等待）</span></div>
<div class="line">    <span class="keywordflow">return</span> (asset as TextAsset)?.text ?? <span class="keywordflow">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="stringliteral">&quot;Asset not found&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="a_reflection_baking_build_observer_8cs_html_a0100be52d45f14348918ea69ec09f959"><div class="ttname"><a href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a></div><div class="ttdeci">UnityEngine.Debug Debug</div><div class="ttdef"><b>Definition</b> ReflectionBakingBuildObserver.cs:10</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_progress_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Cysharp.Threading.Tasks.Progress</a></div><div class="ttdoc">Lightweight IProgress[T] factory.</div><div class="ttdef"><b>Definition</b> Progress.cs:11</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">Cysharp.Threading.Tasks.PlayerLoopTiming</a></div><div class="ttdeci">PlayerLoopTiming</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:72</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">Cysharp.Threading.Tasks.UniTask</a></div><div class="ttdoc">Lightweight unity specified task-like object.</div><div class="ttdef"><b>Definition</b> UniTask.Bridge.cs:11</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a1481fa022bf24e63e5668832fdadab80"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">Cysharp.Threading.Tasks.UniTask.SwitchToThreadPool</a></div><div class="ttdeci">static SwitchToThreadPoolAwaitable SwitchToThreadPool()</div><div class="ttdef"><b>Definition</b> UniTask.Threading.cs:57</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a185785658b777347c3eb9480a9dc8068"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a185785658b777347c3eb9480a9dc8068">Cysharp.Threading.Tasks.UniTask.WaitUntil</a></div><div class="ttdeci">static UniTask WaitUntil(Func&lt; bool &gt; predicate, PlayerLoopTiming timing=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.WaitUntil.cs:13</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a49b4d5a8350f7eb8ec7ec47590b81efc"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">Cysharp.Threading.Tasks.UniTask.DelayFrame</a></div><div class="ttdeci">static UniTask DelayFrame(int delayFrameCount, PlayerLoopTiming delayTiming=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:137</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a64a8a0cd199604c90d89a8e88160eb80"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a64a8a0cd199604c90d89a8e88160eb80">Cysharp.Threading.Tasks.UniTask.WaitForFixedUpdate</a></div><div class="ttdeci">static YieldAwaitable WaitForFixedUpdate()</div><div class="ttdoc">Same as UniTask.Yield(PlayerLoopTiming.LastFixedUpdate).</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:112</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a7714cd296ad74e9e0a268573c8e08a53"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">Cysharp.Threading.Tasks.UniTask.WhenAll</a></div><div class="ttdeci">static UniTask WhenAll(params UniTask[] tasks)</div><div class="ttdef"><b>Definition</b> UniTask.WhenAll.cs:31</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a7e9e192d460e9b7c9151cfb0faa93d14"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Cysharp.Threading.Tasks.UniTask.Delay</a></div><div class="ttdeci">static UniTask Delay(int millisecondsDelay, bool ignoreTimeScale=false, PlayerLoopTiming delayTiming=PlayerLoopTiming.Update, CancellationToken cancellationToken=default(CancellationToken), bool cancelImmediately=false)</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:147</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a8c208ac2d8c4e186d1c286b6d841b8c1"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a8c208ac2d8c4e186d1c286b6d841b8c1">Cysharp.Threading.Tasks.UniTask.WaitForEndOfFrame</a></div><div class="ttdeci">static YieldAwaitable WaitForEndOfFrame()</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:85</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_aaf67b3510a5a7421126aab2c31855408"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#aaf67b3510a5a7421126aab2c31855408">Cysharp.Threading.Tasks.UniTask.NextFrame</a></div><div class="ttdeci">static UniTask NextFrame()</div><div class="ttdoc">Similar as UniTask.Yield but guaranteed run on next frame.</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:49</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_ac44e0c10cd70fc1369711245698795a1"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Cysharp.Threading.Tasks.UniTask.Yield</a></div><div class="ttdeci">static YieldAwaitable Yield()</div><div class="ttdef"><b>Definition</b> UniTask.Delay.cs:24</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
UniTask 和 AsyncOperation 的基础知识</h1>
<p>UniTask 功能依赖于 C# 7.0（<a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">task-like custom async method builder feature</a>），所以需要<code>Unity 2018.3</code>之后的版本，官方支持的最低版本是<code>Unity 2018.4.13f1</code>。</p>
<p>为什么需要 UniTask（自定义task对象）？因为原生 Task 太重，与 Unity 线程（单线程）相性不好。因为 Unity 的异步对象由 Unity 的引擎层自动调度，所以 UniTask 不使用线程和 SynchronizationContext/ExecutionContext。它实现了更快和更低的分配，并且与Unity完全兼容。</p>
<p>您可以在使用<code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Cysharp.Threading.Tasks</a>;</code>时对<code>AsyncOperation</code>，<code>ResourceRequest</code>，<code>AssetBundleRequest</code>，<code>AssetBundleCreateRequest</code>，<code>UnityWebRequestAsyncOperation</code>，<code>AsyncGPUReadbackRequest</code>，<code>IEnumerator</code>以及其他的异步操作进行 await</p>
<p>UniTask 提供了三种模式的扩展方法。</p>
<div class="fragment"><div class="line">await asyncOperation;</div>
<div class="line">.WithCancellation(CancellationToken);</div>
<div class="line">.ToUniTask(IProgress, <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a>, CancellationToken);</div>
</div><!-- fragment --><p><code>WithCancellation</code>是<code>ToUniTask</code>的简化版本，两者都返回<code>UniTask</code>。有关 cancellation 的详细信息，请参阅：<a href="https://github.com/Cysharp/UniTask#cancellation-and-exception-handling">取消和异常处理</a>部分。</p>
<blockquote class="doxtable">
<p>注意：await 会在 PlayerLoop 执行await对象的相应native生命周期方法时返回（如果条件满足的话），而 WithCancellation 和 ToUniTask 是从指定的 PlayerLoop 生命周期执行时返回。有关 PlayLoop生命周期 的详细信息，请参阅：<a href="https://github.com/Cysharp/UniTask#playerloop">PlayerLoop</a>部分。 </p>
</blockquote>
<blockquote class="doxtable">
<p>注意： AssetBundleRequest 有<code>asset</code>和<code>allAssets</code>，默认 await 返回<code>asset</code>。如果您想得到<code>allAssets</code>，您可以使用<code>AwaitForAllAssets()</code>方法。 </p>
</blockquote>
<p><code>UniTask</code>可以使用<code>UniTask.WhenAll</code>，<code>UniTask.WhenAny</code>，<code>UniTask.WhenEach</code>等实用函数。它们就像<code>Task.WhenAll</code>和<code>Task.WhenAny</code>，但它们返回的数据类型更好用。它们会返回值元组，因此您可以传递多种类型并解构每个结果。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> LoadManyAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 并行加载.</span></div>
<div class="line">    var (a, b, c) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;foo&quot;</span>),</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;bar&quot;</span>),</div>
<div class="line">        LoadAsSprite(<span class="stringliteral">&quot;baz&quot;</span>));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;Sprite&gt;</a> LoadAsSprite(<span class="keywordtype">string</span> path)</div>
<div class="line">{</div>
<div class="line">    var resource = await Resources.LoadAsync&lt;Sprite&gt;(path);</div>
<div class="line">    <span class="keywordflow">return</span> (resource as Sprite);</div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void_html"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">Cysharp.Threading.Tasks.UniTaskVoid</a></div><div class="ttdef"><b>Definition</b> UniTaskVoid.cs:13</div></div>
</div><!-- fragment --><p>如果您想要将一个回调转换为 UniTask，您可以使用<code>UniTaskCompletionSource&lt;T&gt;</code>，它是<code>TaskCompletionSource&lt;T&gt;</code>的轻量级版本。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> WrapByUniTaskCompletionSource()</div>
<div class="line">{</div>
<div class="line">    var utcs = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source.html">UniTaskCompletionSource&lt;int&gt;</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 当操作完成时，调用 utcs.TrySetResult();</span></div>
<div class="line">    <span class="comment">// 当操作失败时，调用 utcs.TrySetException();</span></div>
<div class="line">    <span class="comment">// 当操作取消时，调用 utcs.TrySetCanceled();</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> utcs.Task; <span class="comment">//本质上就是返回了一个 UniTask&lt;int&gt;</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_completion_source.html">Cysharp.Threading.Tasks.UniTaskCompletionSource</a></div><div class="ttdef"><b>Definition</b> UniTaskCompletionSource.cs:574</div></div>
</div><!-- fragment --><p>您可以进行如下转换：<br  />
-<code>Task</code> -&gt; <code>UniTask</code>：使用<code>AsUniTask</code><br  />
-<code>UniTask</code> -&gt; <code>UniTask&lt;AsyncUnit&gt;</code>：使用 <code>AsAsyncUnitUniTask</code><br  />
-<code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>：使用 <code>AsUniTask</code>。<code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>的转换是无消耗的。</p>
<p>如果您想将异步转换为协程，您可以使用&lt;tt&gt;.ToCoroutine()，这对于您想只允许使用协程系统大有帮助。</p>
<p>UniTask 不能 await 两次。这是与.NET Standard 2.1 中引入的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.1">ValueTask/IValueTaskSource</a>具有相同的约束。</p>
<blockquote class="doxtable">
<p>千万不要对 <code>ValueTask&lt;TResult&gt;</code> 实例执行以下操作：</p>
<ul>
<li>多次await实例。</li>
<li>多次调用 AsTask。</li>
<li>在操作尚未完成时调用 .Result 或 .GetAwaiter().GetResult()，或对它们进行多次调用。</li>
<li>对实例进行上述多种操作。</li>
</ul>
<p>如果您执行了上述任何操作，则结果是未定义的。 </p>
</blockquote>
<div class="fragment"><div class="line">var task = <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(10);</div>
<div class="line">await task;</div>
<div class="line">await task; <span class="comment">// 错误，抛出异常</span></div>
</div><!-- fragment --><p>如果实在需要多次 await 一个异步操作，可以使用支持多次调用的<code>UniTask.Lazy</code>。&lt;tt&gt;.Preserve()同样允许多次调用（由 UniTask 内部缓存结果）。这种方法在函数范围内有多次调用时很有用。</p>
<p>同样的，<code>UniTaskCompletionSource</code>可以在同一个地方被 await 多次，或者在很多不同的地方被 await。</p>
<h1><a class="anchor" id="autotoc_md34"></a>
取消和异常处理</h1>
<p>一些 UniTask 工厂方法中有一个<code>CancellationToken cancellationToken = default</code>参数。Unity 的一些异步操作也有<code>WithCancellation(CancellationToken)</code>和<code>ToUniTask(..., CancellationToken cancellation = default)</code>扩展方法。</p>
<p>可以通过原生的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource"><code>CancellationTokenSource</code></a>将 CancellationToken 传递给参数</p>
<div class="fragment"><div class="line">var cts = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line"> </div>
<div class="line">cancelButton.onClick.AddListener(() =&gt;</div>
<div class="line">{</div>
<div class="line">    cts.Cancel();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>).SendWebRequest().WithCancellation(cts.Token);</div>
<div class="line"> </div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(1000, cancellationToken: cts.Token);</div>
</div><!-- fragment --><p>CancellationToken 可通过<code>CancellationTokenSource</code>或 MonoBehaviour 的扩展方法<code>GetCancellationTokenOnDestroy</code>来创建。</p>
<div class="fragment"><div class="line"><span class="comment">// 这个 CancellationToken 的生命周期与 GameObject 的相同</span></div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(1000, cancellationToken: this.GetCancellationTokenOnDestroy());</div>
</div><!-- fragment --><p>对于链式取消，建议所有异步方法的最后一个参数都接受<code>CancellationToken cancellationToken</code>，并将<code>CancellationToken</code>从头传递到尾。</p>
<div class="fragment"><div class="line">await FooAsync(this.GetCancellationTokenOnDestroy());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---</span></div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> FooAsync(CancellationToken cancellationToken)</div>
<div class="line">{</div>
<div class="line">    await BarAsync(cancellationToken);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> BarAsync(CancellationToken cancellationToken)</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3), cancellationToken);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>CancellationToken</code>代表了异步操作的生命周期。您可以不使用默认的 CancellationTokenOnDestroy ，通过自定义的<code>CancellationToken</code>自行管理生命周期。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyBehaviour : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    CancellationTokenSource disableCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    CancellationTokenSource destroyCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnEnable()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (disableCancellation != <span class="keyword">null</span>)</div>
<div class="line">        {</div>
<div class="line">            disableCancellation.Dispose();</div>
<div class="line">        }</div>
<div class="line">        disableCancellation = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDisable()</div>
<div class="line">    {</div>
<div class="line">        disableCancellation.Cancel();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDestroy()</div>
<div class="line">    {</div>
<div class="line">        destroyCancellation.Cancel();</div>
<div class="line">        destroyCancellation.Dispose();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>在Unity 2022.2之后，Unity在<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour-destroyCancellationToken.html">MonoBehaviour.destroyCancellationToken</a>和<a href="https://docs.unity3d.com/ScriptReference/Application-exitCancellationToken.html">Application.exitCancellationToken</a>中添加了 CancellationToken。</p>
<p>当检测到取消时，所有方法都会向上游抛出并传播<code>OperationCanceledException</code>。当异常（不限于<code>OperationCanceledException</code>）没有在异步方法中处理时，它将被传播到<code>UniTaskScheduler.UnobservedTaskException</code>。默认情况下，将接收到的未处理异常作为一般异常写入日志。可以使用<code>UniTaskScheduler.UnobservedExceptionWriteLogType</code>更改日志级别。若想对接收到未处理异常时的处理进行自定义，请为<code>UniTaskScheduler.UnobservedTaskException</code>设置一个委托</p>
<p>而<code>OperationCanceledException</code>是一种特殊的异常，会被<code>UnobservedTaskException</code>无视</p>
<p>如果要取消异步 UniTask 方法中的行为，请手动抛出<code>OperationCanceledException</code>。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> FooAsync()</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> OperationCanceledException();</div>
<div class="line">}</div>
</div><!-- fragment --><p>如果您只想处理异常，忽略取消操作（让其传播到全局处理 cancellation 的地方），请使用异常过滤器。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> BarAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        var x = await FooAsync();</div>
<div class="line">        <span class="keywordflow">return</span> x * 2;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (Exception ex) when (!(ex is OperationCanceledException)) <span class="comment">// 在 C# 9.0 下改成 when (ex is not OperationCanceledException) </span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>抛出和捕获<code>OperationCanceledException</code>有点重度，如果比较在意性能开销，请使用<code>UniTask.SuppressCancellationThrow</code>以避免抛出 OperationCanceledException 。它将返回&lt;tt&gt;(bool IsCanceled, T Result)而不是抛出异常。</p>
<div class="fragment"><div class="line">var (isCanceled, _) = await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a49b4d5a8350f7eb8ec7ec47590b81efc">DelayFrame</a>(10, cancellationToken: cts.Token).<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a5a46cd11ff7472238771e1967150acbd">SuppressCancellationThrow</a>();</div>
<div class="line"><span class="keywordflow">if</span> (isCanceled)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a5a46cd11ff7472238771e1967150acbd"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a5a46cd11ff7472238771e1967150acbd">Cysharp.Threading.Tasks.UniTask.SuppressCancellationThrow</a></div><div class="ttdeci">UniTask&lt; bool &gt; SuppressCancellationThrow()</div><div class="ttdoc">returns (bool IsCanceled) instead of throws OperationCanceledException.</div><div class="ttdef"><b>Definition</b> UniTask.cs:68</div></div>
</div><!-- fragment --><p>注意：仅当您在源头处直接调用<code>UniTask.SuppressCancellationThrow</code>时才会抑制异常抛出。否则，返回值将被转换，且整个管道不会抑制异常抛出。</p>
<p><code>UniTask.Yield</code>和<code>UniTask.Delay</code>等功能依赖于 Unity 的 PlayerLoop，它们在 PlayerLoop 中确定<code>CancellationToken</code>状态。 这意味着当<code>CancellationToken</code>被触发时，它们并不会立即取消。</p>
<p>如果要更改此行为，实现立即取消，可将<code>cancelImmediately</code>标志设置为 true。</p>
<div class="fragment"><div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(cancellationToken, cancelImmediately: <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>注意：比起默认行为，设置 <code>cancelImmediately</code> 为 true 并检测立即取消会有更多的性能开销。 这是因为它使用了<code>CancellationToken.Register</code>；这比在 PlayerLoop 中检查 CancellationToken 更重度。</p>
<h1><a class="anchor" id="autotoc_md35"></a>
超时处理</h1>
<p>超时是取消的一种变体。您可以通过<code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code>设置超时并将 CancellationToken 传递给异步方法。</p>
<div class="fragment"><div class="line">var cts = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); <span class="comment">// 设置5s超时。</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest().WithCancellation(cts.Token);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (ex.CancellationToken == cts.Token)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Timeout&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><code>CancellationTokenSouce.CancelAfter</code>是一个原生的 api。但是在 Unity 中您不应该使用它，因为它依赖于线程计时器。<code>CancelAfterSlim</code>是 UniTask 的扩展方法，它使用 PlayerLoop 代替了线程计时器。 </p>
</blockquote>
<p>如果您想将超时与其他 cancellation 一起使用，请使用<code>CancellationTokenSource.CreateLinkedTokenSource</code>。</p>
<div class="fragment"><div class="line">var cancelToken = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">cancelButton.onClick.AddListener(()=&gt;</div>
<div class="line">{</div>
<div class="line">    cancelToken.Cancel(); <span class="comment">// 点击按钮后取消。</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">var timeoutToken = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); <span class="comment">// 设置5s超时。</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 链接 token</span></div>
<div class="line">    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);</div>
<div class="line"> </div>
<div class="line">    await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest().WithCancellation(linkedTokenSource.Token);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (timeoutToken.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Timeout.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cancelToken.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(<span class="stringliteral">&quot;Cancel clicked.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>为减少每次调用异步方法时用于超时的 CancellationTokenSource 的堆内存分配，您可以使用 UniTask 的<code>TimeoutController</code>进行优化。</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a> timeoutController = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a>(); <span class="comment">// 提前创建好，以便复用。</span></div>
<div class="line"> </div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> FooAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// 您可以通过 timeoutController.Timeout(TimeSpan) 把超时设置传递到 cancellationToken。</span></div>
<div class="line">        await UnityWebRequest.Get(<span class="stringliteral">&quot;http://foo&quot;</span>).SendWebRequest()</div>
<div class="line">            .WithCancellation(timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#ad0b83419aa0ff4d43629cc44a61746d1">Timeout</a>(TimeSpan.FromSeconds(5)));</div>
<div class="line">        timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a660360e136262cb21ee507bfe3e82677">Reset</a>(); <span class="comment">// 当 await 完成后调用 Reset（停止超时计时器，并准备下一次复用）。</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (OperationCanceledException ex)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (timeoutController.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a83ef18b291adc1577249beb3561ecdef">IsTimeout</a>())</div>
<div class="line">        {</div>
<div class="line">            UnityEngine.Debug.Log(<span class="stringliteral">&quot;timeout&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">Cysharp.Threading.Tasks.TimeoutController</a></div><div class="ttdef"><b>Definition</b> TimeoutController.cs:15</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_a660360e136262cb21ee507bfe3e82677"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a660360e136262cb21ee507bfe3e82677">Cysharp.Threading.Tasks.TimeoutController.Reset</a></div><div class="ttdeci">void Reset()</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:100</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_a83ef18b291adc1577249beb3561ecdef"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#a83ef18b291adc1577249beb3561ecdef">Cysharp.Threading.Tasks.TimeoutController.IsTimeout</a></div><div class="ttdeci">bool IsTimeout()</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:95</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller_html_ad0b83419aa0ff4d43629cc44a61746d1"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html#ad0b83419aa0ff4d43629cc44a61746d1">Cysharp.Threading.Tasks.TimeoutController.Timeout</a></div><div class="ttdeci">CancellationToken Timeout(int millisecondsTimeout)</div><div class="ttdef"><b>Definition</b> TimeoutController.cs:51</div></div>
</div><!-- fragment --><p>如果您想将超时结合其他取消源一起使用，请使用<code>new TimeoutController(CancellationToken)</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a> timeoutController;</div>
<div class="line">CancellationTokenSource clickCancelSource;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    this.clickCancelSource = <span class="keyword">new</span> CancellationTokenSource();</div>
<div class="line">    this.timeoutController = <span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_timeout_controller.html">TimeoutController</a>(clickCancelSource);</div>
<div class="line">}</div>
</div><!-- fragment --><p>注意：UniTask 有&lt;tt&gt;.Timeout，&lt;tt&gt;.TimeoutWithoutException方法，但如果可以的话，尽量不要使用这些方法，请传递<code>CancellationToken</code>。因为&lt;tt&gt;.Timeout是在任务外部执行，所以无法停止超时任务。&lt;tt&gt;.Timeout意味着超时后忽略结果。如果您将一个<code>CancellationToken</code>传递给该方法，它将从任务内部执行，因此可以停止正在运行的任务。</p>
<h1><a class="anchor" id="autotoc_md36"></a>
进度</h1>
<p>一些 Unity 的异步操作具有<code>ToUniTask(IProgress&lt;float&gt; progress = null, ...)</code>的扩展方法。</p>
<div class="fragment"><div class="line">var progress = <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html">Progress</a>.Create&lt;<span class="keywordtype">float</span>&gt;(x =&gt; <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x));</div>
<div class="line"> </div>
<div class="line">var request = await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>)</div>
<div class="line">    .SendWebRequest()</div>
<div class="line">    .ToUniTask(progress: progress);</div>
</div><!-- fragment --><p>您不应该使用原生的<code>new System.Progress&lt;T&gt;</code>，因为每次调用它都会产生堆内存分配。请改用<code><a class="el" href="class_cysharp_1_1_threading_1_1_tasks_1_1_progress.html" title="Lightweight IProgress[T] factory.">Cysharp.Threading.Tasks.Progress</a></code>。这个 progress 工厂类有两个方法，<code>Create</code>和<code>CreateOnlyValueChanged</code>。<code>CreateOnlyValueChanged</code>仅在进度值更新时调用。</p>
<p>为调用者实现 IProgress 接口会更好，这样不会因使用 lambda 而产生堆内存分配。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Foo : MonoBehaviour, IProgress&lt;float&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Report(<span class="keywordtype">float</span> value)</div>
<div class="line">    {</div>
<div class="line">        UnityEngine.Debug.Log(value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> WebRequest()</div>
<div class="line">    {</div>
<div class="line">        var request = await UnityWebRequest.Get(<span class="stringliteral">&quot;http://google.co.jp&quot;</span>)</div>
<div class="line">            .SendWebRequest()</div>
<div class="line">            .ToUniTask(progress: <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
PlayerLoop</h1>
<p>UniTask 运行在自定义的<a href="https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoop.html">PlayerLoop</a>中。UniTask 中基于 PlayerLoop 的方法（如<code>Delay</code>、<code>DelayFrame</code>、<code>asyncOperation.ToUniTask</code>等）接受这个<code>PlayerLoopTiming</code>。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5">PlayerLoopTiming</a></div>
<div class="line">{</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4">Initialization</a> = 0,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45">LastInitialization</a> = 1,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5">EarlyUpdate</a> = 2,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b">LastEarlyUpdate</a> = 3,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e">FixedUpdate</a> = 4,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b">LastFixedUpdate</a> = 5,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c">PreUpdate</a> = 6,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283">LastPreUpdate</a> = 7,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6">Update</a> = 8,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8">LastUpdate</a> = 9,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754">PreLateUpdate</a> = 10,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73">LastPreLateUpdate</a> = 11,</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef">PostLateUpdate</a> = 12,</div>
<div class="line">    <a class="code hl_enumvalue" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726">LastPostLateUpdate</a> = 13</div>
<div class="line">    </div>
<div class="line"><span class="preprocessor">#if UNITY_2020_2_OR_NEWER</span></div>
<div class="line">    TimeUpdate = 14,</div>
<div class="line">    LastTimeUpdate = 15,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a06933067aafd48425d67bcb01bba5cb6">Cysharp.Threading.Tasks.PlayerLoopTiming.Update</a></div><div class="ttdeci">@ Update</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:85</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a130dbe2167c2e49d358df61baa5281f8">Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate</a></div><div class="ttdeci">@ LastUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:86</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a17074fe64f3574dd955b293b6bc318e5">Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate</a></div><div class="ttdeci">@ EarlyUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:76</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a1e16b5803e4568fe51993be41d2de283">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate</a></div><div class="ttdeci">@ LastPreUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:83</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a3303e42cf193ee9f4ec38e2f12fa2b45">Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization</a></div><div class="ttdeci">@ LastInitialization</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:74</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a4d6938dc46ac97dde005fab44a01386c">Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate</a></div><div class="ttdeci">@ PreUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:82</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a536dca0e06e538df35e0818ee4a415ef">Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate</a></div><div class="ttdeci">@ PostLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:91</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a61bcd96a2c1f8026527cbf2019d6e9a4">Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization</a></div><div class="ttdeci">@ Initialization</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:73</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8060996f870a3704762d12e792027e7b">Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate</a></div><div class="ttdeci">@ LastFixedUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:80</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a8b53aee04ecc8a97220b3f0a6a891f73">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate</a></div><div class="ttdeci">@ LastPreLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:89</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9c1ca4069e206318b33ef896d3dd204e">Cysharp.Threading.Tasks.PlayerLoopTiming.FixedUpdate</a></div><div class="ttdeci">@ FixedUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:79</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5a9f97e7c3f2108861559ca75d08fd3754">Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate</a></div><div class="ttdeci">@ PreLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:88</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5aa63b3924fa0f9dbf4c93441835a12726">Cysharp.Threading.Tasks.PlayerLoopTiming.LastPostLateUpdate</a></div><div class="ttdeci">@ LastPostLateUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:92</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a972e6091a619e304ee8dbcb2508fecf5ac0763f595f0e041928aff8c13ce78f6b">Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate</a></div><div class="ttdeci">@ LastEarlyUpdate</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:77</div></div>
</div><!-- fragment --><p>它表明了异步任务会在哪个时机运行，您可以查阅<a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">PlayerLoopList.md</a>以了解 Unity 的默认 PlayerLoop 以及注入的 UniTask 的自定义循环。</p>
<p><code>PlayerLoopTiming.Update</code>与协程中的<code>yield return null</code>类似，但它会在<code>ScriptRunBehaviourUpdate</code>时，Update（Update 和 uGUI 事件(button.onClick等）之前被调用，而 yield return null 是在<code>ScriptRunDelayedDynamicFrameRate</code>时被调用。<code>PlayerLoopTiming.FixedUpdate</code>类似于<code>WaitForFixedUpdate</code>。</p>
<blockquote class="doxtable">
<p><code>PlayerLoopTiming.LastPostLateUpdate</code>不等同于协程的<code>yield return new WaitForEndOfFrame()</code>。协程的 WaitForEndOfFrame 似乎在 PlayerLoop 完成后运行。一些需要协程结束帧的方法(<code>Texture2D.ReadPixels</code>，<code>ScreenCapture.CaptureScreenshotAsTexture</code>，<code>CommandBuffer</code>等)在 async/await 时无法正常工作。在这些情况下，请将 MonoBehaviour（用于运行协程）传递给<code>UniTask.WaitForEndOfFrame</code>。例如，<code>await UniTask.WaitForEndOfFrame(this);</code>是<code>yield return new WaitForEndOfFrame()</code>轻量级无堆内存分配的替代方案。 </p>
</blockquote>
<blockquote class="doxtable">
<p>注意：在 Unity 2023.1或更高的版本中，<code>await UniTask.WaitForEndOfFrame();</code>不再需要 MonoBehaviour。因为它使用了<code>UnityEngine.Awaitable.EndOfFrameAsync</code>。 </p>
</blockquote>
<p><code>yield return null</code>和<code>UniTask.Yield</code>相似但不同。<code>yield return null</code>总是返回下一帧但<code>UniTask.Yield</code>返回下一次调用。也就是说，<code>UniTask.Yield(PlayerLoopTiming.Update)</code>在 <code>PreUpdate</code>上调用，它返回同一帧。<code>UniTask.NextFrame()</code>保证返回下一帧，您可以认为它的行为与<code>yield return null</code>一致。</p>
<blockquote class="doxtable">
<p>UniTask.Yield（不带 CancellationToken）是一种特殊类型，返回<code>YieldAwaitable</code>并在 YieldRunner 上运行。它是最轻量和最快的。 </p>
</blockquote>
<p><code>AsyncOperation</code>在原生生命周期返回。例如，await <code>SceneManager.LoadSceneAsync</code>在<code>EarlyUpdate.UpdatePreloading</code>时返回，在此之后，在<code>EarlyUpdate.ScriptRunDelayedStartupFrame</code>时调用已加载场景的<code>Start</code>方法。同样的，<code>await UnityWebRequest</code>在<code>EarlyUpdate.ExecuteMainThreadJobs</code>时返回。</p>
<p>在 UniTask 中，直接 await 使用的是原生生命周期，而<code>WithCancellation</code>和<code>ToUniTask</code>使用的特定的生命周期。这通常不会有问题，但对于<code>LoadSceneAsync</code>，它会导致<code>Start</code>方法与 await 之后的逻辑的执行顺序错乱。所以建议不要使用<code>LoadSceneAsync.ToUniTask</code>。</p>
<blockquote class="doxtable">
<p>注意：在 Unity 2023.1或更高的版本中，当您使用新的<code>UnityEngine.Awaitable</code>方法（如<code>SceneManager.LoadSceneAsync</code>）时，请确保您的文件的 using 指令区域中包含<code>using UnityEngine;</code>。 这可以通过避免使用<code>UnityEngine.AsyncOperation</code>版本来防止编译错误。 </p>
</blockquote>
<p>在堆栈跟踪中，您可以检查它在 PlayerLoop 中的运行位置。</p>
<p><img src="https://user-images.githubusercontent.com/46207/83735571-83caea80-a68b-11ea-8d22-5e22864f0d24.png" alt="image" class="inline"/></p>
<p>默认情况下，UniTask 的 PlayerLoop 在<code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]</code>初始化。</p>
<p>在 BeforeSceneLoad 中调用的方法，它们的执行顺序是不确定的，所以如果您想在其他 BeforeSceneLoad 方法中使用 UniTask，您应该尝试在此之前初始化好 PlayerLoop。</p>
<div class="fragment"><div class="line"><span class="comment">// AfterAssembliesLoaded 表示将会在 BeforeSceneLoad 之前调用</span></div>
<div class="line">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> InitUniTaskLoop()</div>
<div class="line">{</div>
<div class="line">    var loop = PlayerLoop.GetCurrentPlayerLoop();</div>
<div class="line">    <a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.<a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref loop);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">Cysharp.Threading.Tasks.PlayerLoopHelper</a></div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:180</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper_html_a532d6a7102811d3e022a5c0afb83ceaa"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize</a></div><div class="ttdeci">static void Initialize(ref PlayerLoopSystem playerLoop, InjectPlayerLoopTimings injectTimings=InjectPlayerLoopTimings.All)</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:398</div></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_html"><div class="ttname"><a href="namespace_cysharp_1_1_threading.html">Cysharp.Threading</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
<div class="ttc" id="anamespace_cysharp_html"><div class="ttname"><a href="namespace_cysharp.html">Cysharp</a></div><div class="ttdef"><b>Definition</b> SplitterGUILayout.cs:10</div></div>
</div><!-- fragment --><p>如果您导入了 Unity 的<code>Entities</code>包，则会在<code>BeforeSceneLoad</code>将自定义 PlayerLoop 重置为默认值，并注入 ECS 的循环。当 Unity 在 UniTask 的初始化方法执行之后调用了 ECS 的注入方法，UniTask 将不再起作用。</p>
<p>为了解决这个问题，您可以在 ECS 初始化后重新初始化 UniTask PlayerLoop。</p>
<div class="fragment"><div class="line"><span class="comment">// 获取 ECS Loop。</span></div>
<div class="line">var playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 设置 UniTask PlayerLoop。</span></div>
<div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref playerLoop);</div>
</div><!-- fragment --><p>您可以通过调用<code>PlayerLoopHelper.IsInjectedUniTaskPlayerLoop()</code>来诊断 UniTask 的 PlayerLoop 是否准备就绪。并且<code>PlayerLoopHelper.DumpCurrentPlayerLoop</code>还会将所有当前 PlayerLoop 记录到控制台。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Start()</div>
<div class="line">{</div>
<div class="line">    UnityEngine.Debug.Log(<span class="stringliteral">&quot;UniTaskPlayerLoop ready? &quot;</span> + <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.IsInjectedUniTaskPlayerLoop());</div>
<div class="line">    <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.DumpCurrentPlayerLoop();</div>
<div class="line">}</div>
</div><!-- fragment --><p>您可以通过移除未使用的 PlayerLoopTiming 注入来稍微优化循环成本。您可以在初始化时调用<code>PlayerLoopHelper.Initialize(InjectPlayerLoopTimings)</code>。</p>
<div class="fragment"><div class="line">var loop = PlayerLoop.GetCurrentPlayerLoop();</div>
<div class="line"><a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html">PlayerLoopHelper</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_player_loop_helper.html#a532d6a7102811d3e022a5c0afb83ceaa">Initialize</a>(ref loop, <a class="code hl_enumeration" href="namespace_cysharp_1_1_threading_1_1_tasks.html#a5ee78743c74d17fec9af7caec019a2f9">InjectPlayerLoopTimings</a>.Minimum); <span class="comment">// Minimum 就是 Update | FixedUpdate | LastPostLateUpdate</span></div>
<div class="ttc" id="anamespace_cysharp_1_1_threading_1_1_tasks_html_a5ee78743c74d17fec9af7caec019a2f9"><div class="ttname"><a href="namespace_cysharp_1_1_threading_1_1_tasks.html#a5ee78743c74d17fec9af7caec019a2f9">Cysharp.Threading.Tasks.InjectPlayerLoopTimings</a></div><div class="ttdeci">InjectPlayerLoopTimings</div><div class="ttdef"><b>Definition</b> PlayerLoopHelper.cs:103</div></div>
</div><!-- fragment --><p><code>InjectPlayerLoopTimings</code>有三个预设，<code>All</code>，<code>Standard</code>（All 除 LastPostLateUpdate 外），<code>Minimum</code>（<code>Update | FixedUpdate | LastPostLateUpdate</code>）。默认为 All，您可以通过组合来自定义要注入的时机，例如<code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code>。</p>
<p>使用未注入<code>PlayerLoopTiming</code>的<a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>可能会出错。例如，您可以像下列方式那样，为<code>InjectPlayerLoopTimings.Minimum</code>设置<code>BannedSymbols.txt</code></p>
<div class="fragment"><div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.Initialization; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.EarlyUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.d</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastFixedUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastPreUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.PreLateUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.PostLateUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
<div class="line"><span class="stringliteral">F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn&#39;</span>t injected <span class="keyword">this</span> PlayerLoop in <span class="keyword">this</span> project.</div>
<div class="line">F:<a class="code hl_namespace" href="namespace_cysharp.html">Cysharp</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading.html">Threading</a>.<a class="code hl_namespace" href="namespace_cysharp_1_1_threading_1_1_tasks.html">Tasks</a>.PlayerLoopTiming.LastTimeUpdate; Isn<span class="stringliteral">&#39;t injected this PlayerLoop in this project.</span></div>
</div><!-- fragment --><p>您可以将<code>RS0030</code>的严重性配置为错误。</p>
<p><img src="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png" alt="image" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md38"></a>
async void 与 async UniTaskVoid 对比</h1>
<p><code>async void</code>是一个原生的 C# 任务系统，因此它不在 UniTask 系统上运行。也最好不要使用它。<code>async UniTaskVoid</code>是<code>async UniTask</code>的轻量级版本，因为它没有等待完成并立即向<code>UniTaskScheduler.UnobservedTaskException</code>报告错误。如果您不需要等待（即发即弃），那么使用<code>UniTaskVoid</code>会更好。不幸的是，要解除警告，您需要在尾部添加<code>Forget()</code>。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> FireAndForgetMethod()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do anything...</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Caller()</div>
<div class="line">{</div>
<div class="line">    FireAndForgetMethod().Forget();</div>
<div class="line">}</div>
</div><!-- fragment --><p>UniTask 也有<code>Forget</code>方法，与<code>UniTaskVoid</code>类似且效果相同。如果您完全不需要使用<code>await</code>，那么使用<code>UniTaskVoid</code>会更高效。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> DoAsync()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do anything...</span></div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> Caller()</div>
<div class="line">{</div>
<div class="line">    DoAsync().Forget();</div>
<div class="line">}</div>
</div><!-- fragment --><p>要使用注册到事件的异步 lambda，请不要使用<code>async void</code>。您可以使用<code>UniTask.Action</code> 或 <code>UniTask.UnityAction</code>来代替，这两者都通过<code>async UniTaskVoid</code> lambda 来创建委托。</p>
<div class="fragment"><div class="line">Action actEvent;</div>
<div class="line">UnityAction unityEvent; <span class="comment">// UGUI 特供</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 这样是不好的: async void</span></div>
<div class="line">actEvent += async () =&gt; { };</div>
<div class="line">unityEvent += async () =&gt; { };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 这样是可以的: 通过 lamada 创建 Action</span></div>
<div class="line">actEvent += <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ae7caae6a6de30d3b9f0e36b554caf904">Action</a>(async () =&gt; { await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(); });</div>
<div class="line">unityEvent += <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.UnityAction(async () =&gt; { await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>(); });</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_ae7caae6a6de30d3b9f0e36b554caf904"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ae7caae6a6de30d3b9f0e36b554caf904">Cysharp.Threading.Tasks.UniTask.Action</a></div><div class="ttdeci">static Action Action(Func&lt; UniTaskVoid &gt; asyncAction)</div><div class="ttdoc">helper of create add UniTaskVoid to delegate. For example: FooAction = UniTask.Action(async () =&gt; { /...</div><div class="ttdef"><b>Definition</b> UniTask.Factory.cs:137</div></div>
</div><!-- fragment --><p><code>UniTaskVoid</code>也可以用在 MonoBehaviour 的<code>Start</code>方法中。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Sample : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_void.html">UniTaskVoid</a> Start()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// 异步初始化代码。</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md39"></a>
UniTaskTracker</h1>
<p>对于检查（泄露的）UniTasks 很有用。您可以在<code>Window -&gt; UniTask Tracker</code>中打开跟踪器窗口。</p>
<p><img src="https://user-images.githubusercontent.com/46207/83527073-4434bf00-a522-11ea-86e9-3b3975b26266.png" alt="image" class="inline"/></p>
<ul>
<li>Enable AutoReload(Toggle) - 自动重新加载。</li>
<li>Reload - 重新加载视图（重新扫描内存中UniTask实例，并刷新界面）。</li>
<li>GC.Collect - 调用 GC.Collect。</li>
<li>Enable Tracking(Toggle) - 开始跟踪异步/等待 UniTask。性能影响：低。</li>
<li>Enable StackTrace(Toggle) - 在任务启动时捕获 StackTrace。性能影响：高。</li>
</ul>
<p>UniTaskTracker 仅用于调试用途，因为启用跟踪和捕获堆栈跟踪很有用，但会对性能产生重大影响。推荐的用法是只在查找任务泄漏时启用跟踪和堆栈跟踪，并在使用完毕后禁用它们。</p>
<h1><a class="anchor" id="autotoc_md40"></a>
外部拓展</h1>
<p>默认情况下，UniTask 支持 TextMeshPro（<code>BindTo(TMP_Text)</code>和像原生 uGUI <code>InputField</code> 那样的事件扩展，如<code>TMP_InputField</code>）、DOTween（<code>Tween</code>作为可等待的）和 Addressables（<code>AsyncOperationHandle</code>和<code>AsyncOperationHandle&lt;T&gt;</code>作为可等待的）。</p>
<p>它们被定义在了如<code>UniTask.TextMeshPro</code>，<code>UniTask.DOTween</code>，<code>UniTask.Addressables</code>等单独的 asmdef文件中。</p>
<p>从包管理器中导入软件包时，会自动启用对 TextMeshPro 和 Addressables 的支持。 但对于 DOTween 的支持，则需要从<a href="https://assetstore.unity.com/packages/tools/animation/dotween-hotween-v2-27676r">DOTWeen assets</a>中导入并定义脚本定义符号<code>UNITASK_DOTWEEN_SUPPORT</code>后才能启用。</p>
<div class="fragment"><div class="line"><span class="comment">// 动画序列</span></div>
<div class="line">await transform.DOMoveX(2, 10);</div>
<div class="line">await transform.DOMoveZ(5, 20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 并行，并传递 cancellation 用于取消</span></div>
<div class="line">var ct = this.GetCancellationTokenOnDestroy();</div>
<div class="line"> </div>
<div class="line">await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7714cd296ad74e9e0a268573c8e08a53">WhenAll</a>(</div>
<div class="line">    transform.DOMoveX(10, 3).WithCancellation(ct),</div>
<div class="line">    transform.DOScale(10, 3).WithCancellation(ct));</div>
</div><!-- fragment --><p>DOTween 支持的默认行为（<code>await</code>，<code>WithCancellation</code>，<code>ToUniTask</code>） 会等待到 tween 被终止。它适用于 Complete(true/false) 和 Kill(true/false)。但是如果您想复用 tweens（<code>SetAutoKill(false)</code>），它就不能按预期工作。如果您想等待另一个时间点，Tween 中存在以下扩展方法，<code>AwaitForComplete</code>，<code>AwaitForPause</code>，<code>AwaitForPlay</code>，<code>AwaitForRewind</code>，<code>AwaitForStepComplete</code>。</p>
<h1><a class="anchor" id="autotoc_md41"></a>
AsyncEnumerable 和 Async LINQ</h1>
<p>Unity 2020.2 支持 C# 8.0，因此您可以使用<code>await foreach</code>。这是异步时代的新更新符号。</p>
<div class="fragment"><div class="line"><span class="comment">// Unity 2020.2，C# 8.0</span></div>
<div class="line">await <span class="keywordflow">foreach</span> (var _ <span class="keywordflow">in</span> UniTaskAsyncEnumerable.EveryUpdate().WithCancellation(token))</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Update() &quot;</span> + Time.frameCount);</div>
<div class="line">}</div>
</div><!-- fragment --><p>在 C# 7.3 环境中，您可以使用<code>ForEachAsync</code>方法以几乎相同的方式工作。</p>
<div class="fragment"><div class="line"><span class="comment">// C# 7.3(Unity 2018.3~)</span></div>
<div class="line">await UniTaskAsyncEnumerable.EveryUpdate().ForEachAsync(_ =&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Update() &quot;</span> + Time.frameCount);</div>
<div class="line">}, token);</div>
</div><!-- fragment --><p><code>UniTask.WhenEach</code>类似于 .NET 9 的<code>Task.WhenEach</code>，它可以使用新的方式来等待多个任务。</p>
<div class="fragment"><div class="line">await <span class="keywordflow">foreach</span> (var result <span class="keywordflow">in</span> <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.WhenEach(task1, task2, task3))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 结果的类型为 WhenEachResult&lt;T&gt;。</span></div>
<div class="line">    <span class="comment">// 它包含 `T Result` or `Exception Exception`。</span></div>
<div class="line">    <span class="comment">// 您可以检查 `IsCompletedSuccessfully` 或 `IsFaulted` 以确定是访 `.Result` 还是 `.Exception`。</span></div>
<div class="line">    <span class="comment">// 如果希望在 `IsFaulted` 时抛出异常并在成功时获取结果，可以使用 `GetResult()`。</span></div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(result.GetResult());</div>
<div class="line">}</div>
</div><!-- fragment --><p>UniTaskAsyncEnumerable 实现了异步 LINQ，类似于 LINQ 的<code>IEnumerable&lt;T&gt;</code>或 Rx 的 <code>IObservable&lt;T&gt;</code>。所有标准 LINQ 查询运算符都可以应用于异步流。例如，以下代码展示了如何将 Where 过滤器应用于每两次单击运行一次的按钮点击异步流。</p>
<div class="fragment"><div class="line">await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).ForEachAsync(_ =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p>即发即弃（Fire and Forget）风格（例如，事件处理），您也可以使用<code>Subscribe</code>。</p>
<div class="fragment"><div class="line">okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).Subscribe(_ =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p>在引入<code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks_1_1_linq.html">Cysharp.Threading.Tasks.Linq</a>;</code>后，异步 LINQ 将被启用，并且<code>UniTaskAsyncEnumerable</code>在 asmdef 文件<code>UniTask.Linq</code>中定义。</p>
<p>它更接近 UniRx（Reactive Extensions），但 UniTaskAsyncEnumerable 是基于 pull 的异步流，而 Rx 是基于 push 的异步流。请注意，尽管它们相似，但特性不同，细节也有所不同。</p>
<p><code>UniTaskAsyncEnumerable</code>是类似<code>Enumerable</code>的入口点。除了标准查询操作符之外，还为 Unity 提供了其他生成器，例如<code>EveryUpdate</code>、<code>Timer</code>、<code>TimerFrame</code>、<code>Interval</code>、<code>IntervalFrame</code>和<code>EveryValueChanged</code>。此外，还添加了 UniTask 原生的查询操作符，如<code>Append</code>，<code>Prepend</code>，<code>DistinctUntilChanged</code>，<code>ToHashSet</code>，<code>Buffer</code>，<code>CombineLatest</code>，<code>Do</code>，<code>Never</code>，<code>ForEachAsync</code>，<code>Pairwise</code>，<code>Publish</code>，<code>Queue</code>，<code>Return</code>，<code>SkipUntil</code>，<code>TakeUntil</code>，<code>SkipUntilCanceled</code>，<code>TakeUntilCanceled</code>，<code>TakeLast</code>，<code>Subscribe</code>。</p>
<p>以 Func 作为参数的方法具有三个额外的重载，另外两个是<code>***Await</code>和<code>***AwaitWithCancellation</code>。</p>
<div class="fragment"><div class="line">Select(Func&lt;T, TR&gt; selector)</div>
<div class="line">SelectAwait(Func&lt;T, <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;TR&gt;</a>&gt; selector)</div>
<div class="line">SelectAwaitWithCancellation(Func&lt;T, CancellationToken, <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;TR&gt;</a>&gt; selector)</div>
</div><!-- fragment --><p>如果在 func 内部使用<code>async</code>方法，请使用<code>***Await</code>或<code>***AwaitWithCancellation</code>。</p>
<p>如何创建异步迭代器：C# 8.0 支持异步迭代器（<code>async yield return</code>），但它只允许<code>IAsyncEnumerable&lt;T&gt;</code>，当然也需要 C# 8.0。UniTask 支持使用<code>UniTaskAsyncEnumerable.Create</code>方法来创建自定义异步迭代器。</p>
<div class="fragment"><div class="line"><span class="comment">// IAsyncEnumerable，C# 8.0 异步迭代器。（请不要这样使用，因为 IAsyncEnumerable 不被 UniTask 所控制）。</span></div>
<div class="line"><span class="keyword">public</span> async IAsyncEnumerable&lt;int&gt; MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = <span class="keywordflow">default</span>)</div>
<div class="line">{</div>
<div class="line">    var frameCount = 0;</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    <span class="keywordflow">while</span> (!token.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        yield <span class="keywordflow">return</span> frameCount++;</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UniTaskAsyncEnumerable.Create 并用 `await writer.YieldAsync` 代替 `yield return`.</span></div>
<div class="line"><span class="keyword">public</span> IUniTaskAsyncEnumerable&lt;int&gt; MyEveryUpdate()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// writer(IAsyncWriter&lt;T&gt;) 有 `YieldAsync(value)` 方法。</span></div>
<div class="line">    <span class="keywordflow">return</span> UniTaskAsyncEnumerable.Create&lt;<span class="keywordtype">int</span>&gt;(async (writer, token) =&gt;</div>
<div class="line">    {</div>
<div class="line">        var frameCount = 0;</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">        <span class="keywordflow">while</span> (!token.IsCancellationRequested)</div>
<div class="line">        {</div>
<div class="line">            await writer.YieldAsync(frameCount++); <span class="comment">// 代替 `yield return`</span></div>
<div class="line">            await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md42"></a>
可等待事件</h1>
<p>所有 uGUI 组件都实现了<code>***AsAsyncEnumerable</code>，以实现对事件的异步流的转换。</p>
<div class="fragment"><div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 默认情况下，使用了button.GetCancellationTokenOnDestroy 来管理异步生命周期</span></div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    await button.OnClickAsync();</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 更高效的方法</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> (var handler = button.GetAsyncClickEventHandler())</div>
<div class="line">    {</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        await handler.OnClickAsync();</div>
<div class="line">        <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用异步 LINQ</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick(CancellationToken token)</div>
<div class="line">{</div>
<div class="line">    await button.OnClickAsAsyncEnumerable().Take(3).Last();</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用异步 LINQ</span></div>
<div class="line">async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a> TripleClick(CancellationToken token)</div>
<div class="line">{</div>
<div class="line">    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&gt;</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Every clicked&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(<span class="stringliteral">&quot;Three times clicked, complete.&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>所有 MonoBehaviour 消息事件均可通过<code>AsyncTriggers</code>转换成异步流，<code>AsyncTriggers</code>可通过引入<code>using <a class="el" href="namespace_cysharp_1_1_threading_1_1_tasks_1_1_triggers.html">Cysharp.Threading.Tasks.Triggers</a>;</code>来启用。<code>AsyncTriggers</code>可以使用<code>GetAsync***Trigger</code>来创建，并将它作为 UniTaskAsyncEnumerable 来触发。</p>
<div class="fragment"><div class="line">var trigger = this.GetOnCollisionEnterAsyncHandler();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line">await trigger.OnCollisionEnterAsync();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 每次移动触发。</span></div>
<div class="line">await this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =&gt;</div>
<div class="line">{</div>
<div class="line">});</div>
</div><!-- fragment --><p><code>AsyncReactiveProperty</code>，<code>AsyncReadOnlyReactiveProperty</code>是 UniTask 的 ReactiveProperty 版本。<code>BindTo</code>的<code>IUniTaskAsyncEnumerable&lt;T&gt;</code>扩展方法，可以把异步流值绑定到 Unity 组件（Text/Selectable/TMP/Text）。</p>
<div class="fragment"><div class="line">var rp = <span class="keyword">new</span> AsyncReactiveProperty&lt;int&gt;(99);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// AsyncReactiveProperty 本身是 IUniTaskAsyncEnumerable，可以通过 LINQ 进行查询</span></div>
<div class="line">rp.ForEachAsync(x =&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(x);</div>
<div class="line">}, this.GetCancellationTokenOnDestroy()).Forget();</div>
<div class="line"> </div>
<div class="line">rp.Value = 10; <span class="comment">// 推送10给所有订阅者</span></div>
<div class="line">rp.Value = 11; <span class="comment">// 推送11给所有订阅者</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// WithoutCurrent 忽略初始值</span></div>
<div class="line"><span class="comment">// BindTo 绑定 stream value 到 unity 组件.</span></div>
<div class="line">rp.WithoutCurrent().BindTo(this.textComponent);</div>
<div class="line"> </div>
<div class="line">await rp.WaitAsync(); <span class="comment">// 一直等待，直到下一个值被设置</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 同样支持 ToReadOnlyAsyncReactiveProperty</span></div>
<div class="line">var rp2 = <span class="keyword">new</span> AsyncReactiveProperty&lt;int&gt;(99);</div>
<div class="line">var rorp = rp.CombineLatest(rp2, (x, y) =&gt; (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);</div>
</div><!-- fragment --><p>在序列中的异步处理完成之前，pull-based异步流不会获取下一个值。这可能会从按钮等推送类型的事件中溢出数据。</p>
<div class="fragment"><div class="line"><span class="comment">// 在3s延迟结束前，无法获取 event</span></div>
<div class="line">await button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><p>它（在防止双击方面）是有用的，但有时也并非都有用。</p>
<p>使用<code>Queue()</code>方法在异步处理期间也会对事件进行排队。</p>
<div class="fragment"><div class="line"><span class="comment">// 异步处理中对 message 进行排队</span></div>
<div class="line">await button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><p>或使用即发即弃风格的<code>Subscribe</code>。</p>
<div class="fragment"><div class="line">button.OnClickAsAsyncEnumerable().Subscribe(async x =&gt;</div>
<div class="line">{</div>
<div class="line">    await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3));</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
Channel</h1>
<p><code>Channel</code>与<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels?view=netcore-3.1">System.Threading.Tasks.Channels</a>相同，类似于 GoLang Channel。</p>
<p>目前只支持多生产者、单消费者无界 Channel。它可以通过<code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;()</code>来创建。</p>
<p>对于生产者(<code>.Writer</code>)，使用<code>TryWrite</code>来推送值，使用<code>TryComplete</code>来完成 Channel。对于消费者(<code>.Reader</code>)，使用<code>TryRead</code>、<code>WaitToReadAsync</code>、<code>ReadAsync</code>和<code>Completion</code>，<code>ReadAllAsync</code>来读取队列的消息。</p>
<p><code>ReadAllAsync</code>返回<code>IUniTaskAsyncEnumerable&lt;T&gt;</code> 因此可以使用 LINQ 操作符。Reader 只允许单消费者，但可以使用&lt;tt&gt;.Publish()查询操作符来启用多播消息。例如，可以制作发布/订阅工具。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>AsyncMessageBroker&lt;T&gt; : IDisposable</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Channel&lt;T&gt;</a> channel;</div>
<div class="line"> </div>
<div class="line">    IConnectableUniTaskAsyncEnumerable&lt;T&gt; multicastSource;</div>
<div class="line">    IDisposable connection;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> AsyncMessageBroker()</div>
<div class="line">    {</div>
<div class="line">        channel = <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Channel</a>.CreateSingleConsumerUnbounded&lt;T&gt;();</div>
<div class="line">        multicastSource = channel.Reader.ReadAllAsync().Publish();</div>
<div class="line">        connection = multicastSource.Connect(); <span class="comment">// Publish returns IConnectableUniTaskAsyncEnumerable.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Publish(T value)</div>
<div class="line">    {</div>
<div class="line">        channel.Writer.TryWrite(value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> IUniTaskAsyncEnumerable&lt;T&gt; Subscribe()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> multicastSource;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> Dispose()</div>
<div class="line">    {</div>
<div class="line">        channel.Writer.TryComplete();</div>
<div class="line">        connection.Dispose();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_channel_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_channel.html">Cysharp.Threading.Tasks.Channel</a></div><div class="ttdef"><b>Definition</b> Channel.cs:8</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md44"></a>
与 Awaitable 对比</h1>
<p>Unity 6 引入了可等待类型<a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Awaitable.html">Awaitable</a>。简而言之，Awaitable 可以被认为是 UniTask 的一个子集，并且事实上，Awaitable的设计也受 UniTask 的影响。它应该能够处理基于 PlayerLoop 的 await，池化 Task，以及支持以类似的方式使用<code>CancellationToken</code>进行取消。随着它被包含在标准库中，您可能想知道是继续使用 UniTask 还是迁移到 Awaitable。以下是简要指南。</p>
<p>首先，Awaitable 提供的功能与协程提供的功能相同。使用 await 代替<code>yield return</code>；<code>await NextFrameAsync()</code>代替<code>yield return null</code>；<code>WaitForSeconds</code>和<code>EndOfFrame</code>等价。然而，这只是两者之间的差异。就功能而言，它是基于协程的，缺乏基于 Task 的特性。在使用 async/await 的实际应用程序开发中，像<code>WhenAll</code>这样的操作是必不可少的。此外，UniTask 支持许多基于帧的操作（如<code>DelayFrame</code>）和更灵活的 PlayerLoopTiming 控制，这些在 Awaitable 中是不可用的。当然，它也没有跟踪器窗口。</p>
<p>因此，我推荐在应用程序开发中使用 UniTask。UniTask 是 Awaitable 的超集，并包含了许多基本特性。对于库开发，如果您希望避免外部依赖，可以使用 Awaitable 作为方法的返回类型。因为 Awaitable 可以使用<code>AsUniTask</code>转换为 UniTask，所以支持在 UniTask 库中处理基于 Awaitable 的功能。即便是在库开发中，如果您不需要担心依赖关系，使用 UniTask 也会是您的最佳选择。</p>
<h1><a class="anchor" id="autotoc_md45"></a>
单元测试</h1>
<p>Unity 的<code>[UnityTest]</code>属性可以测试协程（IEnumerator）但不能测试异步。<code>UniTask.ToCoroutine</code>将 async/await 桥接到协程，以便您可以测试异步方法。</p>
<div class="fragment"><div class="line">[UnityTest]</div>
<div class="line"><span class="keyword">public</span> IEnumerator DelayIgnore() =&gt; <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a2b4f9a504e35fcfca8a33029931cc393">ToCoroutine</a>(async () =&gt;</div>
<div class="line">{</div>
<div class="line">    var time = Time.realtimeSinceStartup;</div>
<div class="line"> </div>
<div class="line">    Time.timeScale = 0.5f;</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(3), ignoreTimeScale: <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        var elapsed = Time.realtimeSinceStartup - time;</div>
<div class="line">        <a class="code hl_typedef" href="_scene_test_fixture_8cs.html#af7550d85bc26da18b3dd7647bc12d577">Assert</a>.AreEqual(3, (<span class="keywordtype">int</span>)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">finally</span></div>
<div class="line">    {</div>
<div class="line">        Time.timeScale = 1.0f;</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="a_scene_test_fixture_8cs_html_af7550d85bc26da18b3dd7647bc12d577"><div class="ttname"><a href="_scene_test_fixture_8cs.html#af7550d85bc26da18b3dd7647bc12d577">Assert</a></div><div class="ttdeci">ModestTree.Assert Assert</div><div class="ttdef"><b>Definition</b> SceneTestFixture.cs:9</div></div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_a2b4f9a504e35fcfca8a33029931cc393"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a2b4f9a504e35fcfca8a33029931cc393">Cysharp.Threading.Tasks.UniTask.ToCoroutine</a></div><div class="ttdeci">static IEnumerator ToCoroutine(Func&lt; UniTask &gt; taskFactory)</div><div class="ttdef"><b>Definition</b> UniTask.Bridge.cs:12</div></div>
</div><!-- fragment --><p>UniTask 自身的单元测试是使用 Unity Test Runner 和<a href="https://github.com/Cysharp/RuntimeUnitTestToolkit">Cysharp/RuntimeUnitTestToolkit</a>编写的，以集成到 CI 中并检查 IL2CPP 是否正常工作。</p>
<h1><a class="anchor" id="autotoc_md46"></a>
线程池的限制</h1>
<p>大多数 UniTask 方法在单个线程 (PlayerLoop) 上运行，只有<code>UniTask.Run</code>（等同于<code>Task.Run</code>）和<code>UniTask.SwitchToThreadPool</code>在线程池上运行。如果您使用线程池，它将无法与 WebGL 等平台兼容。</p>
<p><code>UniTask.Run</code>现在已弃用。您可以改用<code>UniTask.RunOnThreadPool</code>。并且还要考虑是否可以使用<code>UniTask.Create</code>或<code>UniTask.Void</code>。</p>
<h1><a class="anchor" id="autotoc_md47"></a>
IEnumerator.ToUniTask 的限制</h1>
<p>您可以将协程（IEnumerator）转换为 UniTask（或直接 await），但它有一些限制。</p>
<ul>
<li>不支持<code>WaitForEndOfFrame</code>，<code>WaitForFixedUpdate</code>，<code>Coroutine</code></li>
<li>生命周期与<code>StartCoroutine</code>不一样，它使用指定的<code>PlayerLoopTiming</code>，并且默认情况下，<code>PlayerLoopTiming.Update</code>在 MonoBehaviour 的<code>Update</code>和<code>StartCoroutine</code>的循环之前执行。</li>
</ul>
<p>如果您想要实现从协程到异步的完全兼容转换，请使用<code>IEnumerator.ToUniTask(MonoBehaviour coroutineRunner)</code>重载。它会在传入的 MonoBehaviour 实例中执行 StartCoroutine 并在 UniTask 中等待它完成。</p>
<h1><a class="anchor" id="autotoc_md48"></a>
关于 UnityEditor</h1>
<p>UniTask 可以像编辑器协程一样在 Unity 编辑器上运行。但它有一些限制。</p>
<ul>
<li>UniTask.Delay 的 DelayType.DeltaTime、UnscaledDeltaTime 无法正常工作，因为它们无法在编辑器中获取 deltaTime。因此在 EditMode 下运行时，会自动将 DelayType 更改为能等待正确的时间的<code>DelayType.Realtime</code>。</li>
<li>所有 PlayerLoopTiming 都在<code>EditorApplication.update</code>生命周期上运行。</li>
<li>带<code>-quit</code>的<code>-batchmode</code>不起作用，因为 Unity 不会执行 <code>EditorApplication.update</code> 并在一帧后退出。因此，不要使用<code>-quit</code>并使用<code>EditorApplication.Exit(0)</code>手动退出。</li>
</ul>
<h1><a class="anchor" id="autotoc_md49"></a>
与原生 Task API 对比</h1>
<p>UniTask 有许多原生的类Task API。此表展示了两者相对应的 API。</p>
<p>使用原生类型。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">.NET 类型   </th><th class="markdownTableHeadNone">UniTask 类型    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IProgress&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">&mdash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CancellationToken</code>   </td><td class="markdownTableBodyNone">&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>CancellationTokenSource</code>   </td><td class="markdownTableBodyNone">&mdash;   </td></tr>
</table>
<p>使用 UniTask 类型。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">.NET 类型   </th><th class="markdownTableHeadNone">UniTask 类型    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task</code>/<code>ValueTask</code>   </td><td class="markdownTableBodyNone"><code>UniTask</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task&lt;T&gt;</code>/<code>ValueTask&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTask&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>async void</code>   </td><td class="markdownTableBodyNone"><code>async UniTaskVoid</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+= async () =&gt; { }</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Void</code>, <code>UniTask.Action</code>, <code>UniTask.UnityAction</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&mdash;   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSource</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TaskCompletionSource&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSource&lt;T&gt;</code>/<code>AutoResetUniTaskCompletionSource&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ManualResetValueTaskSourceCore&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>UniTaskCompletionSourceCore&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IValueTaskSource</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskSource</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IValueTaskSource&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskSource&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ValueTask.IsCompleted</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Status.IsCompleted()</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ValueTask&lt;T&gt;.IsCompleted</code>   </td><td class="markdownTableBodyNone"><code>UniTask&lt;T&gt;.Status.IsCompleted()</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>new Progress&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>Progress.Create&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>CancellationToken.Register(UnsafeRegister)</code>   </td><td class="markdownTableBodyNone"><code>CancellationToken.RegisterWithoutCaptureExecutionContext</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CancellationTokenSource.CancelAfter</code>   </td><td class="markdownTableBodyNone"><code>CancellationTokenSource.CancelAfterSlim</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Channel.CreateUnbounded&lt;T&gt;(false){ SingleReader = true }</code>   </td><td class="markdownTableBodyNone"><code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IAsyncEnumerable&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncEnumerable&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IAsyncEnumerator&lt;T&gt;</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncEnumerator&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>IAsyncDisposable</code>   </td><td class="markdownTableBodyNone"><code>IUniTaskAsyncDisposable</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.Delay</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Delay</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.Yield</code>   </td><td class="markdownTableBodyNone"><code>UniTask.Yield</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.Run</code>   </td><td class="markdownTableBodyNone"><code>UniTask.RunOnThreadPool</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.WhenAll</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenAll</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.WhenAny</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenAny</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.WhenEach</code>   </td><td class="markdownTableBodyNone"><code>UniTask.WhenEach</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.CompletedTask</code>   </td><td class="markdownTableBodyNone"><code>UniTask.CompletedTask</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.FromException</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromException</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.FromResult</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromResult</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Task.FromCanceled</code>   </td><td class="markdownTableBodyNone"><code>UniTask.FromCanceled</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Task.ContinueWith</code>   </td><td class="markdownTableBodyNone"><code>UniTask.ContinueWith</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TaskScheduler.UnobservedTaskException</code>   </td><td class="markdownTableBodyNone"><code>UniTaskScheduler.UnobservedTaskException</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md50"></a>
池化配置</h1>
<p>UniTask 通过积极缓存异步 promise 对象实现零堆内存分配（有关技术细节，请参阅博客文章<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — 适用于 Unity 的零堆内存分配的async/await，支持异步 LINQ</a>）。默认情况下，它缓存所有 promise，但您可以通过调用<code>TaskPool.SetMaxPoolSize</code>方法来自定义每种类型的最大缓存大小。<code>TaskPool.GetCacheSizeInfo</code>返回池中当前缓存的对象。</p>
<div class="fragment"><div class="line"><span class="keywordflow">foreach</span> (var (type, size) in <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html">TaskPool</a>.<a class="code hl_function" href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html#ab8f77b900432b83101fda16d4ecfbb41">GetCacheSizeInfo</a>())</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="_reflection_baking_build_observer_8cs.html#a0100be52d45f14348918ea69ec09f959">Debug</a>.Log(type + <span class="stringliteral">&quot;:&quot;</span> + size);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_task_pool_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html">Cysharp.Threading.Tasks.TaskPool</a></div><div class="ttdef"><b>Definition</b> TaskPool.cs:13</div></div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_task_pool_html_ab8f77b900432b83101fda16d4ecfbb41"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_task_pool.html#ab8f77b900432b83101fda16d4ecfbb41">Cysharp.Threading.Tasks.TaskPool.GetCacheSizeInfo</a></div><div class="ttdeci">static IEnumerable&lt;(Type, int)&gt; GetCacheSizeInfo()</div><div class="ttdef"><b>Definition</b> TaskPool.cs:43</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
Profiler 下的堆内存分配</h1>
<p>在 UnityEditor 中，能从 profiler 中看到编译器生成的 AsyncStateMachine 的堆内存分配，但它只出现在Debug（development）构建中。C# 编译器在Debug 构建时将 AsyncStateMachine 生成为类，而在Release 构建时将其生成为结构。</p>
<p>Unity 从2020.1版本开始支持代码优化选项（位于右下角）。</p>
<p><img src="https://user-images.githubusercontent.com/46207/89967342-2f944600-dc8c-11ea-99fc-0b74527a16f6.png" alt="" class="inline"/></p>
<p>在开发构建中，您可以通过将 C# 编译器优化设置为 release 模式来移除 AsyncStateMachine 的堆内存分配。此优化选项也可以通过<code>Compilation.CompilationPipeline-codeOptimization</code>和<code>Compilation.CodeOptimization</code>来设置。</p>
<h1><a class="anchor" id="autotoc_md52"></a>
UniTaskSynchronizationContext</h1>
<p>Unity 的默认 SynchronizationContext(<code>UnitySynchronizationContext</code>) 在性能方面表现不佳。UniTask 绕过<code>SynchronizationContext</code>(和<code>ExecutionContext</code>) 因此 UniTask 不使用它，但如果存在<code>async Task</code>，则仍然使用它。<code>UniTaskSynchronizationContext</code>是<code>UnitySynchronizationContext</code>性能更好的替代品。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>SyncContextInjecter</div>
<div class="line">{</div>
<div class="line">    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> Inject()</div>
<div class="line">    {</div>
<div class="line">        SynchronizationContext.SetSynchronizationContext(<span class="keyword">new</span> <a class="code hl_class" href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context.html">UniTaskSynchronizationContext</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context_html"><div class="ttname"><a href="class_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_synchronization_context.html">Cysharp.Threading.Tasks.UniTaskSynchronizationContext</a></div><div class="ttdef"><b>Definition</b> UniTaskSynchronizationContext.cs:8</div></div>
</div><!-- fragment --><p>这是一个可选的选择，并不总是推荐；<code>UniTaskSynchronizationContext</code>性能不如<code>async UniTask</code>，并且不是完整的 UniTask 替代品。它也不保证与<code>UnitySynchronizationContext</code>完全兼容</p>
<h1><a class="anchor" id="autotoc_md53"></a>
API 文档</h1>
<p>UniTask 的 API 文档托管在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.html">cysharp.github.io/UniTask</a>，使用<a href="https://dotnet.github.io/docfx/">DocFX</a>和<a href="https://github.com/Cysharp/DocfxTemplate">Cysharp/DocfXTemplate</a>生成。</p>
<p>例如，UniTask 的工厂方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.UniTask.html#methods-1">UniTask#methods</a>中查阅。UniTaskAsyncEnumerable 的工厂方法和扩展方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.html#methods-1">UniTaskAsyncEnumerable#methods</a>中查阅。</p>
<h1><a class="anchor" id="autotoc_md54"></a>
UPM 包</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
通过 git URL 安装</h2>
<p>需要支持 git 包路径查询参数的 Unity 版本（Unity &gt;= 2019.3.4f1，Unity &gt;= 2020.1a21）。您可以在包管理器中添加<code><a href="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask">https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</a></code></p>
<p><img src="https://user-images.githubusercontent.com/46207/79450714-3aadd100-8020-11ea-8aae-b8d87fc4d7be.png" alt="image" class="inline"/></p>
<p><img src="https://user-images.githubusercontent.com/46207/83702872-e0f17c80-a648-11ea-8183-7469dcd4f810.png" alt="image" class="inline"/></p>
<p>或在<code>Packages/manifest.json</code>中添加<code>"com.cysharp.unitask": "https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask"</code> 。</p>
<p>UniTask 使用<code>*.*.*</code>发布标签来指定版本，因此如果您要设置指定版本，您可以在后面添加像<code>#2.1.0</code>这样的版本标签。例如<code><a href="https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask">https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</a>#2.1.0</code> 。</p>
<h1><a class="anchor" id="autotoc_md56"></a>
关于 .NET Core</h1>
<p>对于 .NET Core，请使用 NuGet。</p>
<blockquote class="doxtable">
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/UniTask">UniTask</a> </p>
</blockquote>
<p>.NET Core 版本的 UniTask 是 Unity 版本的 UniTask 的子集，它移除了依赖 PlayerLoop 的方法。</p>
<p>相比于原生 Task 和 ValueTask，它能以更高的性能运行，但在使用时应注意忽略 ExecutionContext 和 SynchronizationContext。因为它忽略了 ExecutionContext，<code>AsyncLocal</code>也不起作用。</p>
<p>如果您在内部使用 UniTask，但将 ValueTask 作为外部 API 提供，您可以编写如下代码（受<a href="https://github.com/mgravell/PooledAwait">PooledAwait</a>启发）。</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>ZeroAllocAsyncAwaitInDotNetCore</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> ValueTask&lt;int&gt; DoAsync(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> Core(<span class="keyword">this</span>, x, y);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">static</span> async <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask&lt;int&gt;</a> Core(ZeroAllocAsyncAwaitInDotNetCore <span class="keyword">self</span>, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// do anything...</span></div>
<div class="line">            await Task.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a7e9e192d460e9b7c9151cfb0faa93d14">Delay</a>(TimeSpan.FromSeconds(x + y));</div>
<div class="line">            await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#ac44e0c10cd70fc1369711245698795a1">Yield</a>();</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span> 10;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UniTask 不会返回到原生 SynchronizationContext，但可以使用 `ReturnToCurrentSynchronizationContext`来让他返回</span></div>
<div class="line"><span class="keyword">public</span> ValueTask TestAsync()</div>
<div class="line">{</div>
<div class="line">    await <span class="keyword">using</span> (<a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#acfecddee7d437727fa79345759fbb880">ReturnToCurrentSynchronizationContext</a>())</div>
<div class="line">    {</div>
<div class="line">        await <a class="code hl_struct" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html">UniTask</a>.<a class="code hl_function" href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#a1481fa022bf24e63e5668832fdadab80">SwitchToThreadPool</a>();</div>
<div class="line">        <span class="comment">// do anything..</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task_html_acfecddee7d437727fa79345759fbb880"><div class="ttname"><a href="struct_cysharp_1_1_threading_1_1_tasks_1_1_uni_task.html#acfecddee7d437727fa79345759fbb880">Cysharp.Threading.Tasks.UniTask.ReturnToCurrentSynchronizationContext</a></div><div class="ttdeci">static ReturnToSynchronizationContext ReturnToCurrentSynchronizationContext(bool dontPostWhenSameContext=true, CancellationToken cancellationToken=default)</div><div class="ttdef"><b>Definition</b> UniTask.Threading.cs:81</div></div>
</div><!-- fragment --><p>.NET Core 版本的 UniTask 是为了让用户在与 Unity 共享代码时（例如使用<a href="https://github.com/Cysharp/MagicOnion/">CysharpOnion</a>），能够将 UniTask 用作接口。.NET Core 版本的 UniTask 使得代码共享更加顺畅。</p>
<p><a href="https://github.com/Cysharp/ValueTaskSupplement">Cysharp/ValueTaskSupplement</a>提供了一些实用方法，如 WhenAll，这些方法等效于 UniTask。</p>
<h1><a class="anchor" id="autotoc_md57"></a>
许可证</h1>
<p>此库采用MIT许可证 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
